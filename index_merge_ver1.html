<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>H·ªá th·ªëng kho l·∫°nh ‚Äì RFID & 3 Rooms</title>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root{
      --bg:#ffffff; --panel:#f3f4f6; --card:#ffffff; --muted:#475569; --text:#0f172a; --border:#e5e7eb;
      --ok:#10b981; --warn:#f59e0b; --err:#ef4444; --blue:#2563eb; --pill:#f8fafc; --primary:#0ea5e9; --primary-weak:#e0f2fe;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
    .container{max-width:1100px;margin:26px auto;padding:0 16px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
    h1{margin:0;font-weight:700;font-size:clamp(18px,3vw,26px)}

    .pill{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;border:1px solid var(--border);background:var(--pill);color:var(--muted)}
    .dot{width:10px;height:10px;border-radius:999px;background:#64748b}
    .ok{background:var(--ok)} .warn{background:var(--warn)} .err{background:var(--err)}

    .tabs{display:flex;gap:8px;flex-wrap:wrap}
    .tabbtn{border:1px solid var(--border);background:var(--card);color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
    .tabbtn.active{background:var(--primary);color:#fff;border-color:var(--primary)}

    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.15);margin-top:10px}
    .toolbar{display:flex;gap:10px;align-items:center;padding:12px;border-bottom:1px solid var(--border);flex-wrap:wrap}

    table{width:100%;border-collapse:separate;border-spacing:0}
    thead th{position:sticky;top:0;background:#f8fafc;border-bottom:1px solid var(--border);color:var(--muted);text-align:left}
    th,td{padding:12px;border-bottom:1px solid var(--border)}
    tbody tr:hover{ background:#f1f5f9; }

    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid var(--border);background:var(--pill);color:var(--muted)}
    .b-in{background:rgba(16,185,129,.15);color:#22c55e}
    .b-out{background:rgba(239,68,68,.12);color:#ef4444}
    .badge.on .dot{background:var(--ok)}
    .badge.off .dot{background:var(--err)}
    .badge.open .dot{background:var(--warn)}
    .badge.closed .dot{background:var(--ok)}

    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:var(--card);border:1px solid var(--border);color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;box-shadow:0 1px 0 rgba(0,0,0,.08)}
    button:hover{filter:brightness(1.07)}
    button.danger{background:#ef4444;color:#fff;border-color:#ef4444}
    button.primary{background:var(--primary);color:#0b1220;border-color:var(--primary)}
    input,select{background:var(--card);border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:10px}

    .grid{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:10px;margin-top:10px}
    .relayCard{border:1px solid var(--border);border-radius:12px;padding:12px;background:var(--panel);display:flex;flex-direction:column;gap:8px}
    .relayHead{display:flex;align-items:center;justify-content:space-between}

    .section{display:none}
    .section.active{display:block}

    .footer{display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap;color:var(--muted);padding:10px}
    .roomtabs{display:flex;gap:6px;align-items:center}
    .roomtabs .roombtn{border:1px solid var(--border);background:var(--card);padding:6px 10px;border-radius:10px;cursor:pointer}
    .roomtabs .roombtn.active{background:var(--blue);color:#fff;border-color:var(--blue)}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>H·ªá th·ªëng gi√°m s√°t ph√≤ng kho l·∫°nh</h1>
      <div class="pill"><span id="hdrDot" class="dot"></span><span id="hdrSt">ƒêang kh·ªüi t·∫°o‚Ä¶</span></div>
    </header>

    <div class="tabs">
      <button id="tabRFIDBtn"  class="tabbtn">üì∂ RFID Nh·∫≠t k√Ω</button>
      <button id="tabRoomBtn"  class="tabbtn">üå°Ô∏è Ph√≤ng (3 rooms)</button>
    </div>

    <!-- ===== RFID SECTION ===== -->
    <section id="tabRFID" class="section">
      <div class="card">
        <div class="toolbar">
          <span class="pill">Broker: <code id="rfidBroker" class="mono"></code></span>
          <span class="pill">Topic: <code id="rfidTopic" class="mono"></code></span>
          <span class="pill">T·ªïng b·∫£n tin: <b id="rfidCnt">0</b></span>
          <button id="btnRFIDClear">Xo√° b·∫£ng</button>
          <button id="btnRFIDClearScreen" title="Ch·ªâ xo√° ph·∫ßn hi·ªÉn th·ªã hi·ªán t·∫°i, kh√¥ng xo√° d·ªØ li·ªáu ƒë√£ l∆∞u">Xo√° ch·ªâ tr√™n m√†n h√¨nh</button>
          <button id="btnRFIDRestore" class="primary" title="V·∫Ω l·∫°i t·ª´ d·ªØ li·ªáu ƒë√£ l∆∞u">Kh√¥i ph·ª•c hi·ªÉn th·ªã</button>
          <button id="btnRFIDCSV" class="primary">Xu·∫•t CSV</button>
          <select id="rfidSelDevice"><option value="">T·∫•t c·∫£ thi·∫øt b·ªã</option></select>
          <input id="rfidSearch" placeholder="T√¨m UID / t√™n h√†ng‚Ä¶"/>
        </div>
        <table aria-label="B·∫£ng RFID">
          <thead>
            <tr>
              <th style="width:18%">Thi·∫øt b·ªã</th>
              <th style="width:18%">UID</th>
              <th>T√™n h√†ng</th>
              <th style="width:12%">Action</th>
              <th style="width:22%">Timestamp</th>
            </tr>
          </thead>
          <tbody id="rfidTbody"></tbody>
        </table>
        <div class="footer">
          <small>Gi·ªØ t·ªëi ƒëa <span class="mono" id="rfidMax">200</span> d√≤ng (m·ªõi nh·∫•t ·ªü tr√™n).</small>
          <small class="mono">MQTT 3.1.1 / WebSocket TLS</small>
        </div>
      </div>
    </section>

    <!-- ===== ROOM(S) SECTION ===== -->
    <section id="tabRoom" class="section">
      <div class="card">
        <div class="toolbar" style="justify-content:space-between">
          <div class="controls">
            <span class="pill">Broker: <code id="roomBroker" class="mono"></code></span>
            <span class="pill">Sub: <code id="roomSub" class="mono"></code></span>
            <span class="pill">State: <code id="roomState" class="mono"></code></span>
            <span class="pill">Pub: <code id="roomPub" class="mono"></code></span>
          </div>
          <div class="controls">
            <div class="roomtabs">
              <span>Ph√≤ng:</span>
              <button class="roombtn active" data-room="room1">Room1</button>
              <button class="roombtn" data-room="room2">Room2</button>
              <button class="roombtn" data-room="room3">Room3</button>
            </div>
            <div id="doorBadge" class="badge" title="Tr·∫°ng th√°i c·ª≠a"><span class="dot"></span><span id="doorText">Door: ‚Äî</span></div>
            <div id="sumBadge" class="badge" title="T·ªïng h·ª£p 4 relay"><span class="dot"></span><span id="sumText">Relays: ‚Äî</span></div>
            <button id="allOn"  class="primary"  type="button" title='G·ª≠i {"r1":1,"r2":1,"r3":1,"r4":1}'>All ON</button>
            <button id="allOff" class="danger"   type="button" title='G·ª≠i {"r1":0,"r2":0,"r3":0,"r4":0}'>All OFF</button>
          </div>
        </div>

        <div class="grid" id="relayGrid"></div>

        <div class="toolbar" style="justify-content:flex-start;gap:8px;border-top:1px solid var(--border)">
          <span class="pill">History points: <input id="histMax" type="number" value="200" min="50" max="2000" style="width:90px"></span>
          <button id="histClear">Xo√° bi·ªÉu ƒë·ªì</button>
        </div>
        <div style="padding:12px;height:260px">
          <canvas id="thChart"></canvas>
        </div>

        <table aria-label="B·∫£ng nhi·ªát ƒë·ªô v√† ƒë·ªô ·∫©m" style="margin-top:14px">
          <thead>
            <tr>
              <th>Nhi·ªát ƒë·ªô (¬∞C)</th>
              <th>ƒê·ªô ·∫©m (%RH)</th>
            </tr>
          </thead>
          <tbody id="roomTbody"></tbody>
        </table>
      </div>
    </section>
  </div>

<script>
(function(){
  // ====== MQTT CONFIG ======
  const HOST = 'dcede8aa2beb496b980ed91f6804346e.s1.eu.hivemq.cloud';
  const PORT = 8884; // TLS WebSocket
  const PATH = '/mqtt';
  const USERNAME = 'Huy-DTVT17B';
  const PASSWORD = 'GiaHuy2008@';
  const WS_URL = `wss://${HOST}:${PORT}${PATH}`;

  // ====== ROOMS ======
  const ROOMS = ['room1','room2','room3'];
  let currentRoom = localStorage.getItem('coldroom.currentRoom') || 'room1';

  // Topics (wildcard sub ƒë·ªÉ nh·∫≠n t·∫•t c·∫£, pub th√¨ theo currentRoom)
  const TOPIC = {
    rfid:  'coldroom/esp32-RFID/rfid',
    tele:  'coldroom/+/DHT22',   // subscribe all rooms
    state: 'coldroom/+/out1',    // subscribe all rooms
    pub:   (room)=> `coldroom/${room}/client1`,
    teleOf:(room)=> `coldroom/${room}/DHT22`,
    stateOf:(room)=> `coldroom/${room}/out1`,
  };

  // ====== DOM ======
  const hdrDot = document.getElementById('hdrDot');
  const hdrSt  = document.getElementById('hdrSt');
  const setHdr = (text, cls)=>{ hdrSt.textContent = text; hdrDot.className = 'dot ' + (cls||''); };

  // Tabs
  const tabRFIDBtn = document.getElementById('tabRFIDBtn');
  const tabRoomBtn = document.getElementById('tabRoomBtn');
  const tabRFID = document.getElementById('tabRFID');
  const tabRoom = document.getElementById('tabRoom');
  function activate(tab){
    [tabRFIDBtn, tabRoomBtn].forEach(b=>b.classList.remove('active'));
    [tabRFID, tabRoom].forEach(s=>s.classList.remove('active'));
    if(tab==='rfid'){ tabRFIDBtn.classList.add('active'); tabRFID.classList.add('active'); }
    else { tabRoomBtn.classList.add('active'); tabRoom.classList.add('active'); }
    try{ localStorage.setItem('coldroom.activeTab', tab); }catch{}
  }
  tabRFIDBtn.addEventListener('click', ()=>activate('rfid'));
  tabRoomBtn.addEventListener('click', ()=>activate('room'));
  activate(localStorage.getItem('coldroom.activeTab') || 'rfid');

  // Init labels
  document.getElementById('rfidBroker').textContent = `${HOST}:${PORT}${PATH}`;
  document.getElementById('rfidTopic').textContent  = TOPIC.rfid;

  const roomBrokerEl = document.getElementById('roomBroker');
  const roomSubEl    = document.getElementById('roomSub');
  const roomStateEl  = document.getElementById('roomState');
  const roomPubEl    = document.getElementById('roomPub');

  function refreshRoomLabels(){
    roomBrokerEl.textContent = `${HOST}:${PORT}${PATH}`;
    roomSubEl.textContent    = TOPIC.teleOf(currentRoom);
    roomStateEl.textContent  = TOPIC.stateOf(currentRoom);
    roomPubEl.textContent    = TOPIC.pub(currentRoom);
  }

  // ====== MQTT client ======
  setHdr('ƒêang k·∫øt n·ªëi‚Ä¶','warn');
  const client = mqtt.connect(WS_URL, {
    clientId: 'webapp-' + Math.random().toString(16).slice(2),
    username: USERNAME,
    password: PASSWORD,
    clean: true,
    reconnectPeriod: 2000,
    connectTimeout: 15000,
    keepalive: 60,
    protocolVersion: 4,
  });

  client.on('connect', () => {
    setHdr('ƒê√£ k·∫øt n·ªëi','ok');
    client.subscribe([TOPIC.rfid, TOPIC.tele, TOPIC.state], { qos: 0 }, (err) => {
      if(err) setHdr('Sub l·ªói: ' + err.message, 'err');
      else {
        // ping l·∫•y state c·ªßa ph√≤ng hi·ªán t·∫°i
        try { client.publish(TOPIC.pub(currentRoom), JSON.stringify({ getState:1 }), { qos:0, retain:false }); } catch {}
      }
    });
  });
  client.on('reconnect', () => setHdr('ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i‚Ä¶','warn'));
  client.on('close', () => setHdr('M·∫•t k·∫øt n·ªëi','err'));
  client.on('error', (e) => setHdr('L·ªói: ' + (e?.message || e), 'err'));

  // ====== Utils ======
  const debounce = (fn, ms=180)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };
  const safeDate = (iso)=>{ try{ return new Date(iso).toLocaleString('vi-VN'); }catch{ return new Date().toLocaleString('vi-VN'); } };
  const parseRoomFromTopic = (topic)=>{
    // 'coldroom/<room>/(DHT22|out1)'
    const parts = topic.split('/');
    return (parts.length>=3 && parts[0]==='coldroom') ? parts[1] : '';
  };

  // ====== RFID MODULE (kh√¥ng ƒë·ªïi nhi·ªÅu) ======
  const rfid = (function(){
    const tbody = document.getElementById('rfidTbody');
    const cntEl = document.getElementById('rfidCnt');
    const selDevice = document.getElementById('rfidSelDevice');
    const search = document.getElementById('rfidSearch');
    const rows = [];
    const deviceSet = new Set();
    const MAX_KEEP = 200;
    document.getElementById('rfidMax').textContent = MAX_KEEP;

    const LS_ROWS = 'rfidLogRows.v1';
    const LS_FILTER = 'rfidLogFilter.v1';

    function addDeviceOpt(d){
      if(!d || deviceSet.has(d)) return;
      deviceSet.add(d);
      const o=document.createElement('option'); o.value=d; o.textContent=d;
      selDevice.appendChild(o);
    }
    function matchesFilter(item){
      if (selDevice.value && item.device_id !== selDevice.value) return false;
      const q = search.value.trim().toLowerCase();
      if (!q) return true;
      return (item.uid||'').toLowerCase().includes(q) || (item.name||'').toLowerCase().includes(q);
    }
    function render(){
      tbody.innerHTML = '';
      cntEl.textContent = rows.length;
      const filtered = rows.filter(matchesFilter);
      for(const it of filtered){
        const tr = document.createElement('tr');
        const badge = it.action === 'IN' ? '<span class="badge b-in">IN</span>' : '<span class="badge b-out">OUT</span>';
        tr.innerHTML = `
          <td>${it.device_id||'‚Äî'}</td>
          <td class="mono">${it.uid||'‚Äî'}</td>
          <td>${it.name||'‚Äî'}</td>
          <td>${badge}</td>
          <td class="mono">${safeDate(it.timestamp)}</td>`;
        tbody.appendChild(tr);
      }
    }
    let saveTimer;
    function saveState(){
      const capped = rows.slice(0, MAX_KEEP);
      clearTimeout(saveTimer);
      saveTimer = setTimeout(()=>{
        try{
          localStorage.setItem(LS_ROWS, JSON.stringify(capped));
          localStorage.setItem(LS_FILTER, JSON.stringify({ sel: selDevice.value || '', q: search.value || '' }));
        }catch(e){ console.warn('Kh√¥ng th·ªÉ l∆∞u localStorage:', e); }
      }, 150);
    }
    function loadState(){
      try{
        const savedRows = JSON.parse(localStorage.getItem(LS_ROWS) || '[]');
        if (Array.isArray(savedRows) && savedRows.length){
          rows.length = 0;
          for (const it of savedRows){
            if (it && typeof it === 'object'){
              rows.push(it); addDeviceOpt(it.device_id);
            }
          }
          if (rows.length > MAX_KEEP) rows.length = MAX_KEEP;
        }
        const f = JSON.parse(localStorage.getItem(LS_FILTER) || '{}');
        if (f && typeof f === 'object'){
          if (typeof f.sel === 'string'){ if (f.sel && !deviceSet.has(f.sel)) addDeviceOpt(f.sel); selDevice.value = f.sel || ''; }
          if (typeof f.q === 'string') search.value = f.q;
        }
      }catch(e){ console.warn('Kh√¥ng th·ªÉ kh√¥i ph·ª•c localStorage:', e); }
    }

    document.getElementById('btnRFIDClear').addEventListener('click', ()=>{
      rows.length = 0;
      try{ localStorage.removeItem(LS_ROWS); localStorage.removeItem(LS_FILTER); }catch{}
      deviceSet.clear();
      while (selDevice.options.length > 1) selDevice.remove(1);
      search.value = '';
      render();
      setHdr('ƒê√£ xo√° to√†n b·ªô b·∫£ng & localStorage', 'warn');
    });

    document.getElementById('btnRFIDClearScreen').addEventListener('click', ()=>{
      tbody.innerHTML = '';
      setHdr('ƒê√£ xo√° HI·ªÇN TH·ªä b·∫£ng (d·ªØ li·ªáu v·∫´n ƒë∆∞·ª£c gi·ªØ)', 'warn');
    });

    document.getElementById('btnRFIDRestore').addEventListener('click', ()=>{
      render();
      setHdr('ƒê√£ kh√¥i ph·ª•c hi·ªÉn th·ªã b·∫£ng t·ª´ d·ªØ li·ªáu ƒë√£ l∆∞u', 'ok');
    });

    document.getElementById('btnRFIDCSV').addEventListener('click', ()=>{
      const data = rows.filter(matchesFilter);
      const hdr = ['device_id','uid','name','action','timestamp'];
      const csv = [hdr.join(',')].concat(data.map(r => hdr.map(k => '"' + String(r[k] ?? '').replaceAll('"','""') + '"').join(','))).join('\n');
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const ts = new Date().toISOString().replaceAll(':','-').split('.')[0];
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `rfid-log_${ts}.csv`; a.click(); URL.revokeObjectURL(a.href);
    });

    selDevice.addEventListener('change', ()=>{ render(); saveState(); });
    document.getElementById('rfidSearch').addEventListener('input', debounce(()=>{ render(); saveState(); }, 160));

    function handleRFIDMessage(payload){
      try{
        const msg = JSON.parse(payload);
        const item = {
          device_id: msg.device_id || '',
          uid: String(msg.uid||'').toUpperCase(),
          name: msg.name || '',
          action: String(msg.action||'').toUpperCase(),
          timestamp: msg.timestamp || new Date().toISOString()
        };
        if (!item.uid || !item.action) return;
        addDeviceOpt(item.device_id);
        rows.unshift(item);
        if (rows.length > MAX_KEEP) rows.length = MAX_KEEP;
        saveState();
        render();
      }catch(e){ console.warn('Kh√¥ng parse ƒë∆∞·ª£c RFID JSON:', payload); }
    }

    loadState(); render(); saveState();
    return { handleRFIDMessage };
  })();

  // ====== ROOM(S) MODULE ======
  const roomMod = (function(){
    // UI shared area (hi·ªÉn th·ªã theo ph√≤ng ƒëang ch·ªçn)
    const tbody = document.getElementById('roomTbody');
    const grid = document.getElementById('relayGrid');
    const sumBadge = document.getElementById('sumBadge');
    const sumText  = document.getElementById('sumText');
    const doorBadge= document.getElementById('doorBadge');
    const doorText = document.getElementById('doorText');
    const histMaxEl = document.getElementById('histMax');

    // T·∫°o UI n√∫t relay (4 c√°i)
    const relayKeys = ['r1','r2','r3','r4'];
    const relayUI = {};
    grid.innerHTML = '';
    relayKeys.forEach((k, idx) => {
      const n = idx+1;
      const card = document.createElement('div');
      card.className = 'relayCard';
      card.innerHTML = `
        <div class='relayHead'>
          <strong>Relay ${n}</strong>
          <div id='${k}Badge' class='badge'><span class='dot'></span><span id='${k}Text'>${k.toUpperCase()}: ‚Äî</span></div>
        </div>
        <div class='controls'>
          <button id='${k}On'  class='primary' type='button' title='G·ª≠i {"${k}":1}'>ON</button>
          <button id='${k}Off' class='danger'  type='button' title='G·ª≠i {"${k}":0}'>OFF</button>
        </div>`;
      grid.appendChild(card);
      relayUI[k] = {
        badgeEl: card.querySelector('#'+k+'Badge'),
        textEl:  card.querySelector('#'+k+'Text'),
        onBtn:   card.querySelector('#'+k+'On'),
        offBtn:  card.querySelector('#'+k+'Off'),
      };
    });

    // Publish helpers: theo ph√≤ng hi·ªán t·∫°i
    function publish(obj){
      const payload = JSON.stringify(obj);
      if (client && client.connected){
        client.publish(TOPIC.pub(currentRoom), payload, { qos:0, retain:false });
        setHdr('ƒê√£ g·ª≠i ' + payload + ' ‚Üí ' + TOPIC.pub(currentRoom), 'ok');
      } else setHdr('Ch∆∞a k·∫øt n·ªëi, kh√¥ng th·ªÉ g·ª≠i', 'err');
    }
    document.getElementById('allOn').addEventListener('click', ()=> publish({r1:1,r2:1,r3:1,r4:1}));
    document.getElementById('allOff').addEventListener('click',()=> publish({r1:0,r2:0,r3:0,r4:0}));
    relayKeys.forEach(k=>{
      relayUI[k].onBtn.addEventListener('click',  ()=> publish({ [k]:1 }));
      relayUI[k].offBtn.addEventListener('click', ()=> publish({ [k]:0 }));
    });

    // ===== History ƒëa ph√≤ng =====
    const LS_HIST_PREFIX = 'roomTH.hist.v1.';
    const LS_HIST_LIMIT  = 'roomTH.hist.limit'; // l∆∞u limit d√πng chung
    // B·ªô nh·ªõ theo ph√≤ng
    const hist = {
      room1: { labels:[], t:[], h:[] },
      room2: { labels:[], t:[], h:[] },
      room3: { labels:[], t:[], h:[] },
    };

    // Chart ƒë∆°n, d·ªØ li·ªáu thay theo ph√≤ng
    const ctx = document.getElementById('thChart').getContext('2d');
    let chart = new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [
        { label: 'Nhi·ªát ƒë·ªô (¬∞C)', data: [], tension: .25, pointRadius: 0 },
        { label: 'ƒê·ªô ·∫©m (%RH)',  data: [], tension: .25, pointRadius: 0 }
      ]},
      options: {
        responsive: true, maintainAspectRatio: false,
        interaction: { mode: 'nearest', intersect: false },
        plugins: { legend: { labels: { color: getComputedStyle(document.documentElement).getPropertyValue('--text') } } },
        scales: {
          x: { ticks: { autoSkip:true, maxRotation:0, color:getComputedStyle(document.documentElement).getPropertyValue('--muted') }, grid:{ color:'rgba(148,163,184,.15)' } },
          y: { ticks: { color:getComputedStyle(document.documentElement).getPropertyValue('--muted') }, grid:{ color:'rgba(148,163,184,.12)' } }
        }
      }
    });

    function limitForHist(){ 
      const v = Number(localStorage.getItem(LS_HIST_LIMIT));
      const n = Number.isFinite(v) && v>=50 && v<=2000 ? v : Number(histMaxEl.value)||200;
      return Math.max(50, Math.min(2000, n));
    }

    function persistHistory(room){
      try{
        const pack = {
          labels: hist[room].labels,
          t: hist[room].t,
          h: hist[room].h
        };
        localStorage.setItem(LS_HIST_PREFIX + room, JSON.stringify(pack));
        localStorage.setItem(LS_HIST_LIMIT, String(limitForHist()));
      }catch(e){ console.warn('Kh√¥ng l∆∞u ƒë∆∞·ª£c history:', e); }
    }

    function loadHistory(room){
      try{
        const pack = JSON.parse(localStorage.getItem(LS_HIST_PREFIX + room) || 'null');
        if (pack && Array.isArray(pack.labels)){
          hist[room].labels = pack.labels || [];
          hist[room].t = pack.t || [];
          hist[room].h = pack.h || [];
        }
      }catch(e){ console.warn('Kh√¥ng kh√¥i ph·ª•c ƒë∆∞·ª£c history:', e); }
    }
    // n·∫°p t·∫•t c·∫£ ph√≤ng (ƒë·ªÉ chuy·ªÉn nhanh)
    ROOMS.forEach(r => loadHistory(r));
    const savedLimit = limitForHist();
    histMaxEl.value = savedLimit;

    function applyChartRoom(room){
      const data = hist[room];
      chart.data.labels = data.labels;
      chart.data.datasets[0].data = data.t;
      chart.data.datasets[1].data = data.h;
      chart.update('none');
    }

    function appendTelemetry(room, t, h){
      const L = limitForHist();
      const data = hist[room];
      const label = new Date().toLocaleTimeString('vi-VN', { hour12:false });
      data.labels.push(label); data.t.push(Number(t)); data.h.push(Number(h));
      while(data.labels.length > L){ data.labels.shift(); data.t.shift(); data.h.shift(); }
      if (room === currentRoom) chart.update('none');
      persistHistory(room);
    }

    // UI: clear ch·ªâ ph√≤ng hi·ªán t·∫°i
    document.getElementById('histClear').addEventListener('click', ()=>{
      const data = hist[currentRoom];
      data.labels = []; data.t = []; data.h = [];
      applyChartRoom(currentRoom);
      try{ localStorage.removeItem(LS_HIST_PREFIX + currentRoom); }catch{}
      setHdr(`ƒê√£ xo√° l·ªãch s·ª≠ bi·ªÉu ƒë·ªì c·ªßa ${currentRoom}`, 'warn');
    });
    histMaxEl.addEventListener('change', ()=>{
      const L = limitForHist();
      localStorage.setItem(LS_HIST_LIMIT, String(L));
      const d = hist[currentRoom];
      while(d.labels.length > L){ d.labels.shift(); d.t.shift(); d.h.shift(); }
      applyChartRoom(currentRoom);
      persistHistory(currentRoom);
    });

    // ===== State/door/relays ƒëa ph√≤ng =====
    // Cache tr·∫°ng th√°i theo ph√≤ng ƒë·ªÉ khi ƒë·ªïi ph√≤ng l√† hi·ªÉn th·ªã ngay
    const stateCache = {
      room1: { door:null, r:{r1:null,r2:null,r3:null,r4:null} },
      room2: { door:null, r:{r1:null,r2:null,r3:null,r4:null} },
      room3: { door:null, r:{r1:null,r2:null,r3:null,r4:null} },
    };

    function updateDoorBadge(room, val01){
      const open = Number(val01) === 1;
      if (room === currentRoom){
        doorBadge.classList.remove('open','closed');
        doorBadge.classList.add(open ? 'open' : 'closed');
        doorText.textContent = 'Door: ' + (open ? 'OPEN' : 'CLOSED');
      }
      stateCache[room].door = open ? 1 : 0;
    }
    function setRelayBadge(room, key, val01){
      const on = Number(val01) === 1;
      if (room === currentRoom){
        const ui = relayUI[key];
        if (ui){
          ui.badgeEl.classList.remove('on','off');
          ui.badgeEl.classList.add(on ? 'on' : 'off');
          ui.textEl.textContent = key.toUpperCase() + ': ' + (on ? 'ON' : 'OFF');
        }
      }
      stateCache[room].r[key] = on ? 1 : 0;
      updateSumBadge(room);
    }
    function updateSumBadge(room){
      const s = stateCache[room].r;
      const vals = Object.values(s).filter(v=>v!==null);
      if (room !== currentRoom) return;
      if (vals.length===0){ sumText.textContent = 'Relays: ‚Äî'; sumBadge.classList.remove('on','off'); return; }
      const onCount = vals.reduce((a,b)=>a+(b?1:0),0);
      sumText.textContent = `Relays: ${onCount}/${vals.length} ON`;
      sumBadge.classList.remove('on','off');
      if (onCount===vals.length) sumBadge.classList.add('on');
      else if (onCount===0) sumBadge.classList.add('off');
    }

    function handleStateFrom(room, msg){
      try{
        const obj = JSON.parse(msg);
        // legacy
        if (obj.relay !== undefined) setRelayBadge(room,'r1', obj.relay===true?1:obj.relay===false?0:Number(obj.relay));
        // r1..r4
        ['r1','r2','r3','r4'].forEach(k=>{
          if (obj[k] !== undefined){
            const v = obj[k]===true?1:obj[k]===false?0:Number(obj[k]);
            if (v===0||v===1) setRelayBadge(room, k, v);
          }
        });
        // array
        const arr = Array.isArray(obj.relays) ? obj.relays : Array.isArray(obj.relayArray) ? obj.relayArray : null;
        if (arr && arr.length){
          for(let i=0;i<Math.min(arr.length, 4);i++){
            const v = arr[i]===true?1:arr[i]===false?0:Number(arr[i]);
            if (v===0||v===1) setRelayBadge(room, relayKeys[i], v);
          }
        }
        // door
        if (obj.door !== undefined){
          const dv = obj.door===true?1:obj.door===false?0:Number(obj.door);
          if (dv===0||dv===1) updateDoorBadge(room, dv);
        }
      }catch(e){ console.warn('STATE JSON error:', msg); }
    }

    function handleTelemetryFrom(room, msg){
      let t=null,h=null;
      try{
        const o = JSON.parse(msg);
        t = (o.temp ?? o.temperature ?? o.T ?? null);
        h = (o.humi ?? o.humidity ?? o.H ?? null);
      }catch(_){
        const parts = String(msg).split(/[;,\s]+/).filter(Boolean);
        if(parts.length>=2){ t=parseFloat(parts[0]); h=parseFloat(parts[1]); }
      }
      if(Number.isFinite(t) && Number.isFinite(h)){
        // b·∫£ng: ch·ªâ hi·ªÉn th·ªã cho ph√≤ng ƒëang ch·ªçn
        if (room === currentRoom){
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${Number(t).toFixed(1)}</td><td>${Number(h).toFixed(1)}</td>`;
          tbody.replaceChildren(tr);
        }
        appendTelemetry(room, t, h);
      } else console.warn('Kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c d·ªØ li·ªáu:', msg);
    }

    // Khi ƒë·ªïi ph√≤ng: c·∫≠p nh·∫≠t UI theo cache + n·∫°p chart/b·∫£ng
    function applyRoomSwitch(room){
      // labels topic
      refreshRoomLabels();
      // door + relays t·ª´ cache
      const st = stateCache[room];
      if (st.door!==null) updateDoorBadge(room, st.door);
      ['r1','r2','r3','r4'].forEach(k=>{
        if (st.r[k]!==null) setRelayBadge(room,k,st.r[k]);
      });
      updateSumBadge(room);
      // chart
      applyChartRoom(room);
      // y√™u c·∫ßu state m·ªõi nh·∫•t
      try { client.publish(TOPIC.pub(room), JSON.stringify({ getState:1 }), { qos:0, retain:false }); } catch {}
    }

    // Public API cho router message
    return { handleStateFrom, handleTelemetryFrom, applyRoomSwitch };
  })();

  // ====== ROOM selector buttons ======
  const roomBtns = Array.from(document.querySelectorAll('.roombtn'));
  function setCurrentRoom(room){
    if (!ROOMS.includes(room)) return;
    currentRoom = room;
    localStorage.setItem('coldroom.currentRoom', currentRoom);
    roomBtns.forEach(b=>{
      b.classList.toggle('active', b.dataset.room===room);
    });
    roomMod.applyRoomSwitch(room);
  }
  roomBtns.forEach(b => b.addEventListener('click', ()=> setCurrentRoom(b.dataset.room)));
  refreshRoomLabels();
  setCurrentRoom(currentRoom); // load l·∫ßn ƒë·∫ßu

  // ====== ROUTE MQTT messages ======
  client.on('message', (topic, payload) => {
    const msg = payload.toString();
    if (topic === TOPIC.rfid)   return rfid.handleRFIDMessage(msg);
    // state/tele of any room
    const room = parseRoomFromTopic(topic);
    if (topic.startsWith('coldroom/') && topic.endsWith('/out1'))   return roomMod.handleStateFrom(room, msg);
    if (topic.startsWith('coldroom/') && topic.endsWith('/DHT22'))  return roomMod.handleTelemetryFrom(room, msg);
  });

  // ====== Note b·∫£o m·∫≠t ======
  console.warn('‚ö†Ô∏è L∆∞u √Ω: USERNAME/PASSWORD MQTT ƒëang ·ªü client-side. C√¢n nh·∫Øc token t·∫°m th·ªùi ho·∫∑c proxy n·∫øu deploy c√¥ng khai.');
})();
</script>
</body>
</html>
