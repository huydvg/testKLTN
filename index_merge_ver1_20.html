<!doctype html>
<html lang="vi">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ƒê·ªì √°n t·ªët nghi·ªáp ‚Äì H·ªá th·ªëng gi√°m s√°t kho l·∫°nh</title>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #f8fafc;
      --panel: #f1f5f9;
      --card: #ffffff;
      --muted: #334155;
      --text: #0f172a;
      --border: #e2e8f0;
      --ok: #10b981;
      --warn: #f59e0b;
      --err: #ef4444;
      --blue: #2563eb;
      --pill: #ffffff;
      --primary: #06b6d4;
      --primary-weak: #cffafe;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 15px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      max-width: 100%;
      margin: 16px auto;
      padding: 0 32px
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px
    }

    h1 {
      margin: 0;
      font-weight: 700;
      font-size: clamp(18px, 3vw, 26px)
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--pill);
      color: var(--muted)
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #64748b
    }

    .ok {
      background: var(--ok)
    }

    .warn {
      background: var(--warn)
    }

    .err {
      background: var(--err)
    }

    .tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap
    }

    .tabbtn {
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600
    }

    .tabbtn.active {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary)
    }

    .tabbtn.small {
      padding: 6px 10px;
      font-size: 13px
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .15);
      margin-top: 10px
    }

    .toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 12px;
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap
    }

    th.expireCol {
      min-width: 160px
    }

    th.stayCol {
      min-width: 220px;
      width: 220px;
      text-align: center;
    }

    td.stayCell {
      min-width: 220px;
      white-space: nowrap;
      font-weight: 700;
      text-align: center;
    }

    td.expireCell {
      white-space: normal;
      word-break: keep-all;
      font-size: 13px;
      line-height: 1.3;
      text-align: center;
      font-weight: 800;
    }

    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0
    }

    thead th {
      position: sticky;
      top: 0;
      background: #f8fafc;
      border-bottom: 1px solid var(--border);
      color: var(--muted);
      text-align: left
    }

    th,
    td {
      padding: 14px 12px;
      border-bottom: 1px solid var(--border);
      font-size: 14px
    }

    tbody tr:hover {
      background: #f1f5f9
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid var(--border);
      background: var(--pill);
      color: var(--muted)
    }

    .b-in {
      background: rgba(16, 185, 129, .18);
      color: #16a34a;
      font-weight: 900
    }

    .b-out {
      background: rgba(239, 68, 68, .16);
      color: #dc2626;
      font-weight: 900
    }

    .badge.on .dot {
      background: var(--ok)
    }

    .badge.off .dot {
      background: var(--err)
    }

    .badge.open .dot {
      background: var(--warn)
    }

    .badge.closed .dot {
      background: var(--ok)
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap
    }

    button {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 1px 0 rgba(0, 0, 0, .08)
    }

    button:hover {
      filter: brightness(1.07)
    }

    button.danger {
      background: #ef4444;
      color: #fff;
      border-color: #ef4444
    }

    button.primary {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary)
    }

    input,
    select {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(1, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px
    }

    .section {
      display: none
    }

    .section.active {
      display: block
    }

    .rfidPane {
      display: none
    }

    .rfidPane.active {
      display: block
    }

    .footer {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      color: var(--muted);
      padding: 10px
    }

    .roomtabs {
      display: flex;
      gap: 6px;
      align-items: center
    }

    .roomtabs .roombtn {
      border: 1px solid var(--border);
      background: var(--card);
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer
    }

    .roomtabs .roombtn.active {
      background: var(--blue);
      color: #fff;
      border-color: var(--blue)
    }

    .rfidStats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 8px;
      padding: 10px 12px;
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }

    .rfidStat {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, .04);
    }

    .rfidStatLabel {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .06em;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .rfidStatValue {
      font-size: 18px;
      font-weight: 900
    }

    .filterRow {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--card);
    }

    .filterChip {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--panel);
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-weight: 800;
    }

    .filterChip.active {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary)
    }

    .filterSwitch {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      margin-left: auto
    }

    .filterSwitch input {
      margin: 0
    }

    .peltierBar {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 12px;
      border-top: 1px solid var(--border)
    }

    .range {
      appearance: none;
      height: 8px;
      border-radius: 999px;
      background: #e5e7eb;
      outline: none;
      width: 220px
    }

    .range::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      border: 2px solid #0ea5e955;
      cursor: pointer
    }

    .range::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border: 0;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer
    }

    .modebtn {
      border: 1px solid var(--border);
      background: var(--card);
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer
    }

    .modebtn.active {
      background: var(--blue);
      color: #fff;
      border-color: var(--blue)
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      padding: 12px;
      border-top: 1px solid var(--border)
    }

    .stat {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      text-align: center;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .08)
    }

    .statLabel {
      font-size: 12px;
      letter-spacing: .02em;
      text-transform: uppercase;
      color: var(--muted)
    }

    .statValue {
      font-weight: 900;
      line-height: 1;
      font-size: clamp(20px, 5vw, 40px)
    }

    .statUnit {
      font-weight: 900;
      line-height: 1;
      font-size: clamp(20px, 5vw, 40px)
    }

    .hidden {
      display: none !important
    }

    .led {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #9ca3af;
      border: 1px solid var(--border);
      box-shadow: inset 0 -1px 3px rgba(0, 0, 0, .25)
    }

    .led.red {
      background: #ef4444;
      box-shadow: 0 0 0 4px rgba(239, 68, 68, .12), 0 0 10px rgba(239, 68, 68, .6)
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(239, 68, 68, .7)
      }

      70% {
        box-shadow: 0 0 0 8px rgba(239, 68, 68, 0)
      }

      100% {
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0)
      }
    }

    .led.pulse {
      animation: pulse 1s infinite
    }

    .rangebtn {
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 999px
    }

    .rangebtn.active {
      background: var(--blue);
      color: #fff;
      border-color: var(--blue)
    }

    .bandWrap {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap
    }

    .bandWrap input {
      width: 86px
    }

    .bandTag {
      font-size: 12px;
      font-weight: 900;
      color: var(--muted)
    }

    .autoWrap {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap
    }

    .autoWrap input[type="number"] {
      width: 96px
    }

    .autoHint {
      font-size: 12px;
      color: var(--muted);
      font-weight: 800
    }

    /* ===== MODAL (Popup log T/H) ===== */
    .modalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, .55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 18px;
    }

    .modalOverlay.active {
      display: flex;
    }

    .modal {
      width: min(980px, 100%);
      max-height: min(82vh, 820px);
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, .35);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .modalHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: #f8fafc;
    }

    .modalTitle {
      font-weight: 900;
      letter-spacing: .02em;
    }

    .modalBody {
      padding: 10px 12px;
      overflow: auto;
    }

    .modalTools {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }

    .modalTools .pill {
      padding: 6px 10px;
    }

    .modalClose {
      border: 1px solid var(--border);
      background: var(--card);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 800;
    }

    .miniSwitch {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }

    .miniSwitch input {
      margin: 0
    }

    .tableMini th,
    .tableMini td {
      padding: 10px 10px;
      font-size: 13px;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>ƒê·ªì √°n t·ªët nghi·ªáp ‚Äì H·ªá th·ªëng gi√°m s√°t kho l·∫°nh</h1>
      <div class="pill" id="hdrWrap" hidden>
        <span id="hdrDot" class="dot"></span>
        <span id="hdrSt">ƒêang kh·ªüi t·∫°o‚Ä¶</span>
      </div>
    </header>

    <div class="tabs">
      <button id="tabRFIDBtn" class="tabbtn">üì∂ Qu·∫£n l√Ω h√†ng h√≥a</button>
      <button id="tabRoomBtn" class="tabbtn">üå°Ô∏è Ph√≤ng l·∫°nh</button>
      <button id="tabReportBtn" class="tabbtn">üìä B√°o c√°o</button>
    </div>

    <!-- ===== RFID ===== -->
    <section id="tabRFID" class="section">
      <div class="card">
        <div class="toolbar">
          <span class="pill">Broker: <code id="rfidBroker" class="mono"></code></span>
          <span class="pill">Topic: <code id="rfidTopic" class="mono"></code></span>

          <span class="pill">T·ªïng b·∫£n tin: <b id="rfidCnt">0</b></span>

          <button id="btnRFIDClear">Xo√° b·∫£ng</button>
          <button id="btnRFIDClearScreen" title="Ch·ªâ xo√° ph·∫ßn hi·ªÉn th·ªã hi·ªán t·∫°i, kh√¥ng xo√° d·ªØ li·ªáu ƒë√£ l∆∞u">Xo√° ch·ªâ tr√™n
            m√†n h√¨nh</button>
          <button id="btnRFIDRestore" class="primary" title="V·∫Ω l·∫°i t·ª´ d·ªØ li·ªáu ƒë√£ l∆∞u">Kh√¥i ph·ª•c hi·ªÉn th·ªã</button>
          <button id="btnRFIDCSV" class="primary">Xu·∫•t CSV</button>

          <select id="rfidSelDevice">
            <option value="">T·∫•t c·∫£ thi·∫øt b·ªã</option>
          </select>
          <input id="rfidSearch" placeholder="T√¨m UID / t√™n h√†ng‚Ä¶" />
        </div>

        <div class="rfidStats" id="rfidStats">
          <div class="rfidStat">
            <div class="rfidStatLabel">H√†ng ƒëang trong kho</div>
            <div class="rfidStatValue" id="rfidInStockCount">0</div>
          </div>
          <div class="rfidStat">
            <div class="rfidStatLabel">An to√†n (‚â• 14 ng√†y)</div>
            <div class="rfidStatValue" id="rfidSafeCount">0</div>
          </div>
          <div class="rfidStat">
            <div class="rfidStatLabel">C·∫ßn theo d√µi (7‚Äì13 ng√†y)</div>
            <div class="rfidStatValue" id="rfidWatchCount">0</div>
          </div>
          <div class="rfidStat">
            <div class="rfidStatLabel">S·∫Øp / ƒë√£ h·∫øt h·∫°n (‚â§ 6 ng√†y)</div>
            <div class="rfidStatValue" id="rfidDangerCount">0</div>
          </div>
          <div class="rfidStat">
            <div class="rfidStatLabel">L∆∞·ª£t IN h√¥m nay</div>
            <div class="rfidStatValue" id="rfidInToday">0</div>
          </div>
          <div class="rfidStat">
            <div class="rfidStatLabel">L∆∞·ª£t OUT h√¥m nay</div>
            <div class="rfidStatValue" id="rfidOutToday">0</div>
          </div>

          <div class="rfidStat">
            <div class="rfidStatLabel">Ph√≤ng 1 trong kho</div>
            <div class="rfidStatValue" id="rfidRoom1InStock">0</div>
          </div>
          <div class="rfidStat">
            <div class="rfidStatLabel">Ph√≤ng 2 trong kho</div>
            <div class="rfidStatValue" id="rfidRoom2InStock">0</div>
          </div>
          <div class="rfidStat">
            <div class="rfidStatLabel">Ph√≤ng 3 trong kho</div>
            <div class="rfidStatValue" id="rfidRoom3InStock">0</div>
          </div>
        </div>

        <div class="filterRow">
          <span style="font-size:13px;color:var(--muted)">L·ªçc HSD:</span>
          <button type="button" class="filterChip active" data-hsd="all" id="hsdFilterAll">T·∫•t c·∫£</button>
          <button type="button" class="filterChip" data-hsd="safe" id="hsdFilterSafe">An to√†n</button>
          <button type="button" class="filterChip" data-hsd="watch" id="hsdFilterWatch">C·∫ßn theo d√µi</button>
          <button type="button" class="filterChip" data-hsd="danger" id="hsdFilterDanger">S·∫Øp / ƒë√£ h·∫øt h·∫°n</button>
          <span class="filterSwitch">
            <input type="checkbox" id="onlyInStock">
            <label for="onlyInStock">Ch·ªâ hi·ªÉn th·ªã h√†ng ƒëang trong kho</label>
          </span>
        </div>

        <div class="filterRow">
          <span style="font-size:13px;color:var(--muted)">Ph√≤ng:</span>
          <button type="button" class="filterChip active" data-room="all" id="roomFilterAll">T·∫•t c·∫£</button>
          <button type="button" class="filterChip" data-room="room1" id="roomFilter1">Ph√≤ng 1</button>
          <button type="button" class="filterChip" data-room="room2" id="roomFilter2">Ph√≤ng 2</button>
          <button type="button" class="filterChip" data-room="room3" id="roomFilter3">Ph√≤ng 3</button>
        </div>

        <div class="tabs" style="padding:0 12px 8px 12px;border-bottom:1px solid var(--border);margin-top:0">
          <button id="rfidSubTodayBtn" class="tabbtn small">H√¥m nay</button>
          <button id="rfidSubHistoryBtn" class="tabbtn small">L·ªãch s·ª≠</button>
        </div>

        <div id="rfidPaneToday" class="rfidPane">
          <table aria-label="B·∫£ng RFID h√¥m nay">
            <thead>
              <tr>
                <th style="width:6%">STT</th>
                <th style="width:18%">T√™n h√†ng h√≥a</th>
                <th style="width:10%">Ph√≤ng</th>
                <th style="width:10%">Nhi·ªát ƒë·ªô b·∫£o qu·∫£n</th>
                <th style="width:10%">Tr·∫°ng th√°i nh·∫≠p xu·∫•t</th>
                <th style="width:12%">Ng√†y/th√°ng/nƒÉm</th>
                <th style="width:10%">Th·ªùi gian</th>
                <th style="width:12%">Ng√†y s·∫£n xu·∫•t</th>
                <th style="width:12%">H·∫°n s·ª≠ d·ª•ng</th>
                <th class="stayCol">Th·ªùi gian ƒë√£ ·ªü trong kho</th>
                <th class="expireCol">Th·ªùi gian s·∫Øp qu√° h·∫°n</th>
              </tr>
            </thead>
            <tbody id="rfidTbodyToday"></tbody>
          </table>
        </div>

        <div id="rfidPaneHistory" class="rfidPane">
          <div style="padding:10px 12px;display:flex;align-items:center;gap:8px;flex-wrap:wrap">
            <span>Ch·ªçn ng√†y:</span>
            <select id="rfidHistoryDaySel">
              <option value="">(Ch∆∞a c√≥ l·ªãch s·ª≠)</option>
            </select>
          </div>
          <table aria-label="B·∫£ng RFID l·ªãch s·ª≠">
            <thead>
              <tr>
                <th style="width:6%">STT</th>
                <th style="width:18%">T√™n h√†ng h√≥a</th>
                <th style="width:10%">Ph√≤ng</th>
                <th style="width:10%">Nhi·ªát ƒë·ªô b·∫£o qu·∫£n</th>
                <th style="width:10%">Tr·∫°ng th√°i nh·∫≠p xu·∫•t</th>
                <th style="width:12%">Ng√†y/th√°ng/nƒÉm</th>
                <th style="width:10%">Th·ªùi gian</th>
                <th style="width:12%">Ng√†y s·∫£n xu·∫•t</th>
                <th style="width:12%">H·∫°n s·ª≠ d·ª•ng</th>
                <th class="stayCol">Th·ªùi gian ƒë√£ ·ªü trong kho</th>
                <th class="expireCol">Th·ªùi gian s·∫Øp qu√° h·∫°n</th>
              </tr>
            </thead>
            <tbody id="rfidTbodyHistory"></tbody>
          </table>
        </div>

        <div class="footer">
          <small>Gi·ªØ t·ªëi ƒëa <span class="mono" id="rfidMax">200</span> d√≤ng (m·ªõi nh·∫•t ·ªü tr√™n).</small>
          <small class="mono">MQTT 3.1.1 / WebSocket TLS</small>
        </div>
      </div>
    </section>

    <!-- ===== ROOM ===== -->
    <section id="tabRoom" class="section">
      <div class="card">
        <div class="toolbar" style="justify-content:space-between">
          <div class="controls">
            <span class="pill">Broker: <code id="roomBroker" class="mono"></code></span>
            <span class="pill">Sub: <code id="roomSub" class="mono"></code></span>
            <span class="pill">State: <code id="roomState" class="mono"></code></span>
            <span class="pill">Pub: <code id="roomPub" class="mono"></code></span>
          </div>

          <div class="controls">
            <div class="roomtabs">
              <span>Ph√≤ng:</span>
              <button class="roombtn active" data-room="room1">Room1</button>
              <button class="roombtn" data-room="room2">Room2</button>
              <button class="roombtn" data-room="room3">Room3</button>
            </div>

            <button id="btnOpenTHLog" class="tabbtn small">üìã B·∫£ng ghi T/H</button>

            <div id="doorBadge" class="badge" title="Tr·∫°ng th√°i c·ª≠a">
              <span class="dot"></span><span id="doorText">Door: ‚Äî</span>
            </div>

            <!-- ‚úÖ Toggle c·∫£nh b√°o: nay s·∫Ω ƒëi·ªÅu khi·ªÉn lu√¥n ph·∫ßn c·ª©ng (ESP32) -->
            <label class="pill"
              title="T·∫Øt -> Web ·∫©n c·∫£nh b√°o + g·ª≠i l·ªánh xu·ªëng ESP32 ƒë·ªÉ t·∫Øt c√≤i/b√°o ƒë·ªông ph·∫ßn c·ª©ng (theo ph√≤ng)">
              <input type="checkbox" id="alarmEnableWeb">
              B·∫≠t c·∫£nh b√°o (Web)
            </label>

            <div id="alarmBadge" class="badge hidden" title="C·∫£nh b√°o nhi·ªát ƒë·ªô">
              <span id="alarmDot" class="dot"></span><span id="alarmText">ALARM: ‚Äî</span>
            </div>
            <div id="alarmLED" class="led hidden" title="Nhi·ªát ƒë·ªô v∆∞·ª£t ng∆∞·ª°ng" aria-label="Alarm"></div>
          </div>
        </div>

        <div class="grid" id="relayGrid"></div>

        <div class="peltierBar">
          <span class="pill">Peltier CMD: <code class="mono" id="pelCmdTopic"></code></span>
          <span class="pill">State: <code class="mono" id="pelStateTopic"></code></span>
          <span class="pill">Tele: <code class="mono" id="pelTeleTopic"></code></span>

          <label class="pill" title="B·∫≠t/t·∫Øt ƒë·∫ßu ra BTS7960">
            <input type="checkbox" id="peltierEnable">
            Enable
          </label>

          <div class="controls">
            <button id="modeAuto" class="modebtn" type="button">AUTO</button>
            <button id="modeManual" class="modebtn" type="button">MANUAL</button>
            <button id="modeOff" class="modebtn danger" type="button">T·∫ÆT</button>
          </div>

          <input id="peltierSlider" class="range" type="range" min="0" max="255" step="1" value="0"
            title="Duty 0..255 (manual)" />

          <span class="pill">Duty: <b id="pelDutyLbl">0</b>/255 (<b id="pelPctLbl">0</b>%)</span>
          <span class="pill">Mode: <b id="pelModeLbl">‚Äî</b></span>

          <span class="pill" title="AUTO: tƒÉng duty khi nhi·ªát ƒë·ªô > setpoint, gi·∫£m duty khi g·∫ßn setpoint ƒë·ªÉ ·ªïn ƒë·ªãnh">
            <span class="bandTag">AUTO:</span>
            <span class="autoWrap">
              <label class="mono">SP <input id="autoSetpoint" type="number" step="0.1"></label>
              <label class="mono">Boost <input id="autoBoostBand" type="number" step="0.1"></label>
              <label class="mono">Hys <input id="autoHys" type="number" step="0.1"></label>
              <label class="mono">Min <input id="autoMinDuty" type="number" step="1" min="0" max="255"></label>
              <label class="mono">Max <input id="autoMaxDuty" type="number" step="1" min="0" max="255"></label>
              <button id="autoApplyBtn" type="button" class="tabbtn small">√Åp d·ª•ng AUTO</button>
              <span class="autoHint" id="autoExplain">‚Äî</span>
            </span>
          </span>

          <span class="pill"
            title="Ch·ªâ c·∫ßn nh·∫≠p LOW/HIGH. H·ªá th·ªëng t·ª± t·∫°o d·∫£i ALARM (¬±0.5) v√† CLEAR (¬±0.5) ƒë·ªÉ tr√°nh nh·∫•p nh√°y.">
            <span class="bandTag">Ng∆∞·ª°ng:</span>
            <span class="bandWrap">
              <label class="mono">LOW <input id="rangeLowInput" type="number" step="0.1"></label>
              <label class="mono">HIGH <input id="rangeHighInput" type="number" step="0.1"></label>
              <span class="pill" style="padding:6px 10px">Hys: <b>0.5¬∞C</b></span>
              <button id="bandSaveBtn" type="button" class="tabbtn small">L∆∞u</button>
              <button id="bandDefaultBtn" type="button" class="tabbtn small">M·∫∑c ƒë·ªãnh ph√≤ng</button>
              <span class="pill" style="padding:6px 10px" id="bandExplain">‚Äî</span>
            </span>
          </span>
        </div>

        <div class="stats">
          <div class="stat" aria-label="Nhi·ªát ƒë·ªô">
            <div class="statLabel">Nhi·ªát ƒë·ªô</div>
            <div class="statValue"><span id="tempBig">--.-</span></div>
            <div class="statUnit">¬∞C</div>
          </div>
          <div class="stat" aria-label="ƒê·ªô ·∫©m">
            <div class="statLabel">ƒê·ªô ·∫©m</div>
            <div class="statValue"><span id="humiBig">--.-</span></div>
            <div class="statUnit">%RH</div>
          </div>
        </div>

        <div class="toolbar" style="justify-content:flex-start;gap:8px;border-top:1px solid var(--border)">
          <span class="pill">
            History points:
            <input id="histMax" type="number" value="200" min="50" max="2000" style="width:90px">
          </span>
          <span class="pill">
            Kho·∫£ng hi·ªÉn th·ªã:
            <button type="button" class="tabbtn small rangebtn active" data-range="auto">Auto</button>
            <button type="button" class="tabbtn small rangebtn" data-range="30m">~30 ph√∫t</button>
            <button type="button" class="tabbtn small rangebtn" data-range="2h">~2 gi·ªù</button>
            <button type="button" class="tabbtn small rangebtn" data-range="24h">~24 gi·ªù</button>
          </span>
          <button id="histClear">Xo√° bi·ªÉu ƒë·ªì</button>
        </div>

        <div style="padding:12px;height:260px">
          <canvas id="thChart"></canvas>
        </div>

        <div style="padding:12px;border-top:1px solid var(--border)">
          <h3 style="margin:0 0 6px 0;font-size:13px;color:var(--muted);text-transform:uppercase;letter-spacing:.08em;">
            Nh·∫≠t k√Ω c·∫£nh b√°o</h3>
          <table aria-label="Nh·∫≠t k√Ω c·∫£nh b√°o" style="width:100%;border-collapse:separate;border-spacing:0">
            <thead>
              <tr>
                <th style="width:26%">Th·ªùi gian</th>
                <th style="width:18%">Lo·∫°i</th>
                <th>N·ªôi dung</th>
              </tr>
            </thead>
            <tbody id="roomLogTbody"></tbody>
          </table>
        </div>

        <table aria-label="B·∫£ng nhi·ªát ƒë·ªô v√† ƒë·ªô ·∫©m" style="margin-top:14px" class="hidden">
          <thead>
            <tr>
              <th>Nhi·ªát ƒë·ªô (¬∞C)</th>
              <th>ƒê·ªô ·∫©m (%RH)</th>
            </tr>
          </thead>
          <tbody id="roomTbody"></tbody>
        </table>
      </div>
    </section>

    <!-- ===== REPORT ===== -->
    <section id="tabReport" class="section">
      <div class="card">
        <div class="toolbar" style="justify-content:flex-start;gap:10px">
          <span class="pill">Kho d·ªØ li·ªáu: Google Sheet</span>
          <a class="tabbtn small"
            href="https://docs.google.com/spreadsheets/d/1eU0HPzWhDaeF8UvmeHoQMh0lxxxX-ds1ir5rA1F6dus/edit"
            target="_blank" rel="noopener">
            M·ªü Google Sheet
          </a>
        </div>
        <div style="padding:12px 16px 16px 16px;font-size:14px">
          <p>
            T·∫•t c·∫£ s·ª± ki·ªán <b>IN/OUT</b> t·ª´ m√¥-ƒëun RFID ƒë∆∞·ª£c l∆∞u v√†o Google Sheet ƒë·ªÉ d·ªÖ d√†ng
            th·ªëng k√™, l·ªçc theo ng√†y, tr√≠ch xu·∫•t b√°o c√°o ho·∫∑c chia s·∫ª cho qu·∫£n l√Ω kho.
          </p>
          <p>
            M·ªói d√≤ng d·ªØ li·ªáu g·ªìm: ng√†y, gi·ªù, tr·∫°ng th√°i In/Out, t√™n h√†ng h√≥a, <b>ph√≤ng l∆∞u tr·ªØ</b>, ng√†y s·∫£n xu·∫•t (NSX),
            h·∫°n s·ª≠ d·ª•ng (HSD), th·ªùi gian ƒë√£ ·ªü trong kho v√† th·ªùi gian s·∫Øp qu√° h·∫°n.
          </p>
          <p>
            Trang web n√†y hi·ªÉn th·ªã nhanh d·ªØ li·ªáu v√† tr·∫°ng th√°i; Google Sheet l√† n∆°i l∆∞u tr·ªØ l√¢u d√†i,
            ph·ª•c v·ª• in ·∫•n v√† ph√¢n t√≠ch chi ti·∫øt cho ƒë·ªì √°n.
          </p>
        </div>
      </div>
    </section>
  </div>

  <!-- ===== MODAL: B·∫£ng ghi T/H ===== -->
  <div id="thModalOverlay" class="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="B·∫£ng ghi nhi·ªát ƒë·ªô v√† ƒë·ªô ·∫©m">
      <div class="modalHeader">
        <div class="modalTitle">üìã B·∫£ng ghi nhi·ªát ƒë·ªô & ƒë·ªô ·∫©m</div>
        <button class="modalClose" id="btnCloseTHModal">ƒê√≥ng ‚úï</button>
      </div>

      <div class="modalTools">
        <span class="pill">T·ªïng d√≤ng: <b id="thLogCount">0</b></span>

        <span class="miniSwitch pill">
          <input type="checkbox" id="thLogEnable">
          <label for="thLogEnable">B·∫≠t ghi log</label>
        </span>

        <span class="pill">Gi·ªõi h·∫°n:
          <input id="thLogLimit" type="number" min="100" max="10000" value="2000" style="width:90px">
        </span>

        <select id="thLogRoomFilter">
          <option value="all">T·∫•t c·∫£ ph√≤ng</option>
          <option value="room1">Room1</option>
          <option value="room2">Room2</option>
          <option value="room3">Room3</option>
        </select>

        <input id="thLogSearch" placeholder="T√¨m theo th·ªùi gian (VD: 2025-12-18)..." style="min-width:240px">

        <button id="btnTHExportCSV" class="primary">Xu·∫•t CSV</button>
        <button id="btnTHClear" class="danger">Xo√° log</button>
      </div>

      <div class="modalBody">
        <table class="tableMini" aria-label="B·∫£ng log T/H">
          <thead>
            <tr>
              <th style="width:22%">Th·ªùi gian</th>
              <th style="width:10%">Ph√≤ng</th>
              <th style="width:12%">Nhi·ªát ƒë·ªô (¬∞C)</th>
              <th style="width:12%">ƒê·ªô ·∫©m (%RH)</th>
              <th>Ghi ch√∫</th>
            </tr>
          </thead>
          <tbody id="thLogTbody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    (function () {
      // ===== MQTT CONFIG =====
      const HOST = 'dcede8aa2beb496b980ed91f6804346e.s1.eu.hivemq.cloud';
      const PORT = 8884;
      const PATH = '/mqtt';
      const USERNAME = 'Huy-DTVT17B';
      const PASSWORD = 'GiaHuy2008@';
      const WS_URL = `wss://${HOST}:${PORT}${PATH}`;

      const ROOMS = ['room1', 'room2', 'room3'];
      let currentRoom = localStorage.getItem('coldroom.currentRoom') || 'room1';

      const TOPIC = {
        rfid: 'coldroom/esp32-RFID/rfid',
        tele: 'coldroom/+/DHT22',
        state: 'coldroom/+/out1',
        pub: room => `coldroom/${room}/client1`,
        teleOf: room => `coldroom/${room}/DHT22`,
        stateOf: room => `coldroom/${room}/out1`,
        peltierState: 'coldroom/+/peltier_state',
        peltierTele: 'coldroom/+/peltier_tele',
        peltierCmdOf: room => `coldroom/${room}/peltier_cmd`,
      };

      function defaultRange(room) {
        if (room === 'room1') return { low: 6.0, high: 11.0 };
        if (room === 'room2') return { low: 12.0, high: 17.0 };
        return { low: 18.0, high: 26.0 };
      }

      const HYST = 0.5;

      function bandsFromLowHigh(low, high) {
        const lo = Number(low), hi = Number(high);
        if (!Number.isFinite(lo) || !Number.isFinite(hi)) return null;
        const L = Math.min(lo, hi);
        const H = Math.max(lo, hi);

        const clearLow = L + HYST;
        const clearHigh = H - HYST;
        if (clearHigh <= clearLow) {
          const mid = (L + H) / 2;
          return {
            low: L, high: H,
            alarmLowC: L - HYST,
            alarmHighC: H + HYST,
            clearLowC: mid - 0.05,
            clearHighC: mid + 0.05,
          };
        }

        return {
          low: L, high: H,
          alarmLowC: L - HYST,
          alarmHighC: H + HYST,
          clearLowC: L + HYST,
          clearHighC: H - HYST,
        };
      }

      function deriveLowHighFromBands(b) {
        if (Number.isFinite(b?.clearLowC) && Number.isFinite(b?.clearHighC)) {
          return { low: b.clearLowC - HYST, high: b.clearHighC + HYST };
        }
        if (Number.isFinite(b?.alarmLowC) && Number.isFinite(b?.alarmHighC)) {
          return { low: b.alarmLowC + HYST, high: b.alarmHighC - HYST };
        }
        return null;
      }

      // ===== DOM =====
      const hdrWrap = document.getElementById('hdrWrap');
      const hdrDot = document.getElementById('hdrDot');
      const hdrSt = document.getElementById('hdrSt');
      function setHdr(text, cls) {
        hdrWrap.hidden = false;
        hdrSt.textContent = text;
        hdrDot.className = 'dot ' + (cls || '');
      }

      const tabRFIDBtn = document.getElementById('tabRFIDBtn');
      const tabRoomBtn = document.getElementById('tabRoomBtn');
      const tabReportBtn = document.getElementById('tabReportBtn');
      const tabRFID = document.getElementById('tabRFID');
      const tabRoom = document.getElementById('tabRoom');
      const tabReport = document.getElementById('tabReport');

      function activate(tab) {
        [tabRFIDBtn, tabRoomBtn, tabReportBtn].forEach(b => b.classList.remove('active'));
        [tabRFID, tabRoom, tabReport].forEach(s => s.classList.remove('active'));
        if (tab === 'rfid') { tabRFIDBtn.classList.add('active'); tabRFID.classList.add('active'); }
        else if (tab === 'room') { tabRoomBtn.classList.add('active'); tabRoom.classList.add('active'); }
        else if (tab === 'report') { tabReportBtn.classList.add('active'); tabReport.classList.add('active'); }
        else { tab = 'rfid'; tabRFIDBtn.classList.add('active'); tabRFID.classList.add('active'); }
        try { localStorage.setItem('coldroom.activeTab', tab); } catch { }
      }
      tabRFIDBtn.addEventListener('click', () => activate('rfid'));
      tabRoomBtn.addEventListener('click', () => activate('room'));
      tabReportBtn.addEventListener('click', () => activate('report'));
      activate(localStorage.getItem('coldroom.activeTab') || 'rfid');

      const debounce = (fn, ms = 180) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };
      const parseRoomFromTopic = topic => {
        const parts = topic.split('/');
        return (parts.length >= 3 && parts[0] === 'coldroom') ? parts[1] : '';
      };
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v | 0));

      // MQTT client
      let client = null;

      function sendPelCmd(obj) {
        const payload = JSON.stringify(obj);
        const topic = TOPIC.peltierCmdOf(currentRoom);
        console.log('MQTT PUB ‚Üí', topic, payload);
        if (client && client.connected) {
          client.publish(topic, payload, { qos: 0, retain: false });
          setHdr('ƒê√£ g·ª≠i ' + payload + ' ‚Üí ' + topic, 'ok');
        } else {
          setHdr('Ch∆∞a k·∫øt n·ªëi MQTT, kh√¥ng th·ªÉ g·ª≠i', 'err');
        }
      }

      // ===== RFID MODULE =====
      const rfidModule = (function () {
        const tbodyToday = document.getElementById('rfidTbodyToday');
        const tbodyHistory = document.getElementById('rfidTbodyHistory');
        const cntEl = document.getElementById('rfidCnt');
        const selDevice = document.getElementById('rfidSelDevice');
        const search = document.getElementById('rfidSearch');
        const historyDaySel = document.getElementById('rfidHistoryDaySel');
        const subTodayBtn = document.getElementById('rfidSubTodayBtn');
        const subHistoryBtn = document.getElementById('rfidSubHistoryBtn');
        const paneToday = document.getElementById('rfidPaneToday');
        const paneHistory = document.getElementById('rfidPaneHistory');

        const statInStock = document.getElementById('rfidInStockCount');
        const statSafe = document.getElementById('rfidSafeCount');
        const statWatch = document.getElementById('rfidWatchCount');
        const statDanger = document.getElementById('rfidDangerCount');
        const statInToday = document.getElementById('rfidInToday');
        const statOutToday = document.getElementById('rfidOutToday');

        const statRoom1InStock = document.getElementById('rfidRoom1InStock');
        const statRoom2InStock = document.getElementById('rfidRoom2InStock');
        const statRoom3InStock = document.getElementById('rfidRoom3InStock');

        const hsdFilterChips = Array.from(document.querySelectorAll('.filterChip[data-hsd]'));
        const roomFilterChips = Array.from(document.querySelectorAll('.filterChip[data-room]'));
        const onlyInStockEl = document.getElementById('onlyInStock');

        const MAX_KEEP = 200;
        document.getElementById('rfidMax').textContent = MAX_KEEP;

        let rows = [];
        const LS_RFID_ROWS = 'rfid.rows.v2';

        function saveRows() {
          try {
            const compact = rows.map(r => ({
              device_id: r.device_id, uid: r.uid, name: r.name, action: r.action,
              nsx: r.nsx, hsd: r.hsd,
              date: r.date, time: r.time, dayKey: r.dayKey,
              roomKey: r.roomKey, room: r.room,
              tmin: r.tmin, tmax: r.tmax, trange: r.trange,
              tsMillis: r.tsMillis,
              _frozenStaySec: r._frozenStaySec
            }));
            localStorage.setItem(LS_RFID_ROWS, JSON.stringify(compact));
          } catch (e) { console.warn('saveRows fail', e); }
        }

        function loadRows() {
          try {
            const s = localStorage.getItem(LS_RFID_ROWS);
            if (!s) return;
            const arr = JSON.parse(s);
            if (!Array.isArray(arr)) return;

            rows = arr.slice(0, MAX_KEEP).map(x => {
              const ex = computeExpireInfo(x.hsd);
              return {
                ...x,
                expire: ex.text,
                expireColor: ex.color,
                expireTextColor: ex.textColor,
                expireZone: ex.zone,
                expireDays: ex.days,
              };
            });

            deviceSet.clear();
            while (selDevice.options.length > 1) selDevice.remove(1);
            rows.forEach(r => addDeviceOpt(r.device_id));
          } catch (e) { console.warn('loadRows fail', e); }
        }

        let deviceSet = new Set();
        let currentView = localStorage.getItem('rfid.currentView') || 'today';
        let currentHistoryDayKey = '';

        let currentHsdFilter = localStorage.getItem('rfid.hsdFilter') || 'all';
        let currentRoomFilter = localStorage.getItem('rfid.roomFilter') || 'all';
        const LS_ONLY_IN = 'rfid.onlyInStock';
        const LS_ROOM_FILTER = 'rfid.roomFilter';

        function todayKey() { return new Date().toISOString().slice(0, 10); }

        function setView(view) {
          currentView = (view === 'history') ? 'history' : 'today';
          try { localStorage.setItem('rfid.currentView', currentView); } catch { }
          subTodayBtn.classList.toggle('active', currentView === 'today');
          subHistoryBtn.classList.toggle('active', currentView === 'history');
          paneToday.classList.toggle('active', currentView === 'today');
          paneHistory.classList.toggle('active', currentView === 'history');
          render();
        }

        function addDeviceOpt(d) {
          if (!d || deviceSet.has(d)) return;
          deviceSet.add(d);
          const o = document.createElement('option');
          o.value = d;
          o.textContent = d;
          selDevice.appendChild(o);
        }

        function normNoAccent(str) {
          return String(str || '')
            .toLowerCase()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '');
        }

        function normalizeItemName(rawName) {
          if (!rawName) return '';
          const s = normNoAccent(rawName).trim();
          const map = {
            'ca chua': 'C√† chua',
            'ca tim': 'C√† t√≠m',
            'dau cove': 'ƒê·∫≠u cove',
            'tac': 'T·∫Øc',
            'trung': 'Tr·ª©ng',
            'dua leo': 'D∆∞a leo',
            'thuoc vien': 'Thu·ªëc vi√™n',
            'thuoc bot': 'Thu·ªëc b·ªôt',
            'my pham': 'M·ªπ ph·∫©m',
            'nuoc hoa': 'N∆∞·ªõc hoa',
            'banh keo': 'B√°nh k·∫πo',
            'ca phe': 'C√† ph√™',
            'gao': 'G·∫°o',
            'bot mi': 'B·ªôt m√¨',
            'socola': 'Socola',
            'tra': 'Tr√†',
            'vitamin': 'Vitamin',
          };
          return map[s] || rawName;
        }

        function computeExpireInfo(hsdStr) {
          if (!hsdStr) return { text: '', color: '', textColor: '', zone: 'none', days: null };
          const s = String(hsdStr).trim();
          let d = null;
          let m = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(s);
          if (m) d = new Date(parseInt(m[3], 10), parseInt(m[2], 10) - 1, parseInt(m[1], 10));
          else {
            m = /^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(s);
            if (m) d = new Date(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
          }
          if (!d || isNaN(d)) return { text: '', color: '', textColor: '', zone: 'none', days: null };

          const now = new Date();
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          const hsd = new Date(d.getFullYear(), d.getMonth(), d.getDate());
          const diffDays = Math.floor((hsd - today) / (1000 * 60 * 60 * 24));

          if (diffDays >= 14) return { text: `C√≤n ${diffDays} ng√†y`, color: '#16a34a', textColor: '#ffffff', zone: 'safe', days: diffDays };
          if (diffDays >= 7) return { text: `C√≤n ${diffDays} ng√†y`, color: '#f59e0b', textColor: '#111827', zone: 'watch', days: diffDays };
          if (diffDays > 0) return { text: `C√≤n ${diffDays} ng√†y`, color: '#ef4444', textColor: '#ffffff', zone: 'danger', days: diffDays };
          if (diffDays === 0) return { text: 'H·∫øt h·∫°n h√¥m nay', color: '#ef4444', textColor: '#ffffff', zone: 'danger', days: diffDays };
          return { text: `Qu√° h·∫°n ${Math.abs(diffDays)} ng√†y`, color: '#b91c1c', textColor: '#ffffff', zone: 'danger', days: diffDays };
        }

        let liveTimer = null;

        function fmtDuration(sec) {
          sec = Math.max(0, Math.floor(sec || 0));
          const d = Math.floor(sec / 86400); sec %= 86400;
          const h = Math.floor(sec / 3600); sec %= 3600;
          const m = Math.floor(sec / 60);
          const s = sec % 60;

          if (d > 0) return `${d} ng√†y ${h} gi·ªù`;
          if (h > 0) return `${h} gi·ªù ${m} ph√∫t`;
          if (m > 0) return `${m} ph√∫t ${s} gi√¢y`;
          return `${s} gi√¢y`;
        }

        function roomKeyFromPayload(raw) {
          const r1 = String(raw.room ?? raw.Room ?? '').toLowerCase().trim();
          if (['room1', 'room2', 'room3'].includes(r1)) return r1;

          const p = raw.phong ?? raw.Phong ?? raw.roomNo ?? raw.room_no ?? null;
          const n = Number(p);
          if (n === 1) return 'room1';
          if (n === 2) return 'room2';
          if (n === 3) return 'room3';

          return '';
        }

        function roomDisplay(roomKey) {
          if (roomKey === 'room1') return 'Ph√≤ng 1';
          if (roomKey === 'room2') return 'Ph√≤ng 2';
          if (roomKey === 'room3') return 'Ph√≤ng 3';
          return '‚Äî';
        }

        function parseTemp(v) {
          if (v === null || v === undefined) return null;
          const n = Number(v);
          return Number.isFinite(n) ? n : null;
        }

        function normalizeRow(raw) {
          if (!raw || typeof raw !== 'object') return null;

          const ts = raw.timestamp || raw.time || new Date().toISOString();
          const parts = String(ts).split(/[ T]/);
          let dateIso = parts[0] || todayKey();
          let timeStr = (parts[1] || '').slice(0, 8);

          let dateText = dateIso;
          const mm = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateIso);
          if (mm) dateText = `${mm[3]}/${mm[2]}/${mm[1]}`;

          const hsd = raw.hsd || raw.HSD || '';
          const nsx = raw.nsx || raw.NSX || '';
          const ex = computeExpireInfo(hsd);

          const rawName = raw.name || '';
          const itemName = normalizeItemName(rawName);

          const rKey = roomKeyFromPayload(raw) || 'unknown';

          const tmin = parseTemp(raw.tmin ?? raw.TMIN ?? raw.tempMin ?? raw.temp_min);
          const tmax = parseTemp(raw.tmax ?? raw.TMAX ?? raw.tempMax ?? raw.temp_max);
          const trange = (tmin !== null && tmax !== null) ? `${tmin}‚Äì${tmax}¬∞C` : '';

          let tsMillis = Date.parse(ts);
          if (!Number.isFinite(tsMillis)) {
            const tt = timeStr || '00:00:00';
            tsMillis = Date.parse(`${dateIso}T${tt}`);
          }
          if (!Number.isFinite(tsMillis)) tsMillis = Date.now();

          return {
            tsMillis,
            _frozenStaySec: raw._frozenStaySec ?? null,
            device_id: raw.device_id || '',
            uid: String(raw.uid || '').toUpperCase(),
            name: itemName,
            action: String(raw.action || '').toUpperCase(),
            nsx, hsd,
            expire: ex.text,
            expireColor: ex.color,
            expireTextColor: ex.textColor,
            expireZone: ex.zone,
            expireDays: ex.days,
            date: dateText,
            time: timeStr,
            dayKey: dateIso,
            roomKey: rKey,
            room: roomDisplay(rKey),
            tmin, tmax, trange
          };
        }

        function matchesFilter(it, index, stockIndex) {
          if (selDevice.value && it.device_id !== selDevice.value) return false;

          const qRaw = search.value.trim();
          if (qRaw) {
            const q = normNoAccent(qRaw);
            const uidStr = String(it.uid || '').toLowerCase();
            const nameNorm = normNoAccent(it.name);
            if (!uidStr.includes(q) && !nameNorm.includes(q)) return false;
          }

          if (currentHsdFilter && currentHsdFilter !== 'all') {
            if (it.expireZone !== currentHsdFilter) return false;
          }

          if (currentRoomFilter && currentRoomFilter !== 'all') {
            if (it.roomKey !== currentRoomFilter) return false;
          }

          if (onlyInStockEl && onlyInStockEl.checked) {
            if (!it.uid) return false;
            const info = stockIndex[it.uid];
            if (!info || info.lastAction !== 'IN' || info.lastInRow !== index) return false;
          }

          return true;
        }

        function ensureHistoryDaySel() {
          const tKey = todayKey();
          const daySet = new Set(rows.map(r => r.dayKey));
          const all = Array.from(daySet);
          const historyKeys = all.filter(k => k !== tKey).sort().reverse();
          historyDaySel.innerHTML = '';
          if (!historyKeys.length) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = '(Ch∆∞a c√≥ l·ªãch s·ª≠)';
            historyDaySel.appendChild(opt);
            currentHistoryDayKey = '';
            return;
          }
          if (!currentHistoryDayKey || !historyKeys.includes(currentHistoryDayKey)) {
            currentHistoryDayKey = historyKeys[0];
          }
          historyKeys.forEach(k => {
            const opt = document.createElement('option');
            opt.value = k;
            const [y, m, d] = k.split('-');
            opt.textContent = `${d}/${m}/${y}`;
            if (k === currentHistoryDayKey) opt.selected = true;
            historyDaySel.appendChild(opt);
          });
        }

        function buildRow(it, stt) {
          const tr = document.createElement('tr');
          const badge = it.action === 'IN'
            ? '<span class="badge b-in">IN</span>'
            : '<span class="badge b-out">OUT</span>';

          const styleExpire = [];
          if (it.expireColor) styleExpire.push(`background:${it.expireColor}`);
          if (it.expireTextColor) styleExpire.push(`color:${it.expireTextColor}`);
          const styleStr = styleExpire.length ? ` style="${styleExpire.join(';')}"` : '';

          const frozenText = (it._frozenStaySec != null) ? fmtDuration(it._frozenStaySec) : '';

          tr.innerHTML = `
            <td class="mono">${stt}</td>
            <td>${it.name || ''}</td>
            <td><b>${it.room || ''}</b></td>
            <td class="mono"><b>${it.trange || ''}</b></td>
            <td>${badge}</td>
            <td class="mono">${it.date || ''}</td>
            <td class="mono">${it.time || ''}</td>
            <td class="mono">${it.nsx || ''}</td>
            <td class="mono">${it.hsd || ''}</td>
            <td class="mono stayCell"
                data-uid="${it.uid || ''}"
                data-start="${it.tsMillis || 0}"
                data-live="0">${frozenText}</td>
            <td class="mono expireCell"${styleStr}>${it.expire || ''}</td>
          `;
          return tr;
        }

        function computeFrozenStays() {
          const lastInByUid = {};
          for (let i = rows.length - 1; i >= 0; i--) {
            const r = rows[i];
            if (!r.uid) continue;

            if (r.action === 'IN') {
              lastInByUid[r.uid] = { tsMillis: r.tsMillis, rowIndex: i };
            } else if (r.action === 'OUT') {
              const inInfo = lastInByUid[r.uid];
              if (inInfo) {
                const dur = Math.max(0, Math.floor((r.tsMillis - inInfo.tsMillis) / 1000));
                r._frozenStaySec = dur;
                rows[inInfo.rowIndex]._frozenStaySec = dur;
                delete lastInByUid[r.uid];
              }
            }
          }
        }

        function render() {
          cntEl.textContent = rows.length;
          ensureHistoryDaySel();
          tbodyToday.innerHTML = '';
          tbodyHistory.innerHTML = '';

          const tKey = todayKey();
          computeFrozenStays();

          const stockIndex = {};
          for (let i = 0; i < rows.length; i++) {
            const r = rows[i];
            if (!r.uid) continue;
            const u = r.uid;
            if (!stockIndex[u]) stockIndex[u] = { lastAction: r.action, lastInRow: null };
            if (r.action === 'IN' && stockIndex[u].lastInRow === null) stockIndex[u].lastInRow = i;
          }

          let inToday = 0, outToday = 0;
          for (const r of rows) {
            if (r.dayKey === tKey) {
              if (r.action === 'IN') inToday++;
              else if (r.action === 'OUT') outToday++;
            }
          }

          let inStockCount = 0, safeCount = 0, watchCount = 0, dangerCount = 0;
          let room1Count = 0, room2Count = 0, room3Count = 0;

          Object.keys(stockIndex).forEach(uid => {
            const info = stockIndex[uid];
            if (info.lastAction === 'IN' && info.lastInRow != null) {
              const r = rows[info.lastInRow];
              inStockCount++;
              if (r.expireZone === 'safe') safeCount++;
              else if (r.expireZone === 'watch') watchCount++;
              else if (r.expireZone === 'danger') dangerCount++;

              if (r.roomKey === 'room1') room1Count++;
              else if (r.roomKey === 'room2') room2Count++;
              else if (r.roomKey === 'room3') room3Count++;
            }
          });

          statInStock.textContent = inStockCount;
          statSafe.textContent = safeCount;
          statWatch.textContent = watchCount;
          statDanger.textContent = dangerCount;
          statInToday.textContent = inToday;
          statOutToday.textContent = outToday;

          statRoom1InStock.textContent = room1Count;
          statRoom2InStock.textContent = room2Count;
          statRoom3InStock.textContent = room3Count;

          let sttToday = 1, sttHistory = 1;
          for (let i = 0; i < rows.length; i++) {
            const it = rows[i];
            if (it.dayKey === tKey && matchesFilter(it, i, stockIndex)) tbodyToday.appendChild(buildRow(it, sttToday++));
            if (currentHistoryDayKey && it.dayKey === currentHistoryDayKey && matchesFilter(it, i, stockIndex))
              tbodyHistory.appendChild(buildRow(it, sttHistory++));
          }

          if (liveTimer) { clearInterval(liveTimer); liveTimer = null; }

          function updateLiveCells() {
            const now = Date.now();
            const cells = document.querySelectorAll('.stayCell[data-live="1"]');
            cells.forEach(td => {
              const start = Number(td.dataset.start || 0);
              if (!start) return;
              const sec = Math.floor((now - start) / 1000);
              td.textContent = fmtDuration(sec);
            });
          }

          document.querySelectorAll('.stayCell').forEach(td => td.dataset.live = "0");

          Object.keys(stockIndex).forEach(uid => {
            const info = stockIndex[uid];
            if (info && info.lastAction === 'IN' && info.lastInRow != null) {
              const inRow = rows[info.lastInRow];
              const sel = `.stayCell[data-uid="${uid}"][data-start="${inRow.tsMillis}"]`;
              const td = document.querySelector(sel);
              if (td) {
                td.dataset.live = "1";
                td.textContent = fmtDuration((Date.now() - inRow.tsMillis) / 1000);
              }
            }
          });

          document.querySelectorAll('.stayCell[data-live="0"]').forEach(td => {
            const uid = td.dataset.uid;
            const start = Number(td.dataset.start || 0);
            const r = rows.find(x => x.uid === uid && x.tsMillis === start);
            if (r && r._frozenStaySec != null) td.textContent = fmtDuration(r._frozenStaySec);
          });

          liveTimer = setInterval(updateLiveCells, 1000);
        }

        function handleRFIDMessage(payload) {
          try {
            const msg = JSON.parse(payload);
            const it = normalizeRow(msg);
            if (!it || !it.uid) return;

            if (it.roomKey === 'unknown') setHdr('RFID thi·∫øu tr∆∞·ªùng room (room1/2/3) ‚Üí kh√¥ng ph√¢n lo·∫°i ƒë∆∞·ª£c!', 'warn');

            addDeviceOpt(it.device_id);
            rows.unshift(it);
            if (rows.length > MAX_KEEP) rows.length = MAX_KEEP;
            render();
            saveRows();
          } catch (e) { console.warn('RFID JSON error', e); }
        }

        document.getElementById('btnRFIDClear').addEventListener('click', () => {
          rows = []; deviceSet.clear();
          while (selDevice.options.length > 1) selDevice.remove(1);
          render();
          try { localStorage.removeItem(LS_RFID_ROWS); } catch (e) { }
          setHdr('ƒê√£ xo√° to√†n b·ªô b·∫£ng RFID', 'warn');
        });

        document.getElementById('btnRFIDClearScreen').addEventListener('click', () => {
          if (currentView === 'today') tbodyToday.innerHTML = ''; else tbodyHistory.innerHTML = '';
        });

        document.getElementById('btnRFIDRestore').addEventListener('click', render);

        document.getElementById('btnRFIDCSV').addEventListener('click', () => {
          const hdr = ['stt', 'name', 'room', 'temp_range', 'io', 'date', 'time', 'nsx', 'hsd', 'stay', 'expire'];
          const csv = [hdr.join(',')].concat(rows.map((r, idx) => {
            const stay = (r._frozenStaySec != null) ? fmtDuration(r._frozenStaySec) : '';
            const m = {
              stt: idx + 1,
              name: r.name || '',
              room: r.room || '',
              temp_range: r.trange || '',
              io: r.action || '',
              date: r.date || '',
              time: r.time || '',
              nsx: r.nsx || '',
              hsd: r.hsd || '',
              stay,
              expire: r.expire || ''
            };
            return hdr.map(k => '"' + String(m[k]).replace(/"/g, '""') + '"').join(',');
          })).join('\n');
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'rfid-log.csv';
          a.click();
          URL.revokeObjectURL(a.href);
        });

        selDevice.addEventListener('change', render);
        search.addEventListener('input', debounce(render, 160));
        subTodayBtn.addEventListener('click', () => setView('today'));
        subHistoryBtn.addEventListener('click', () => setView('history'));
        historyDaySel.addEventListener('change', () => { currentHistoryDayKey = historyDaySel.value || ''; render(); });

        function applyHsdFilterUI() { hsdFilterChips.forEach(btn => btn.classList.toggle('active', btn.dataset.hsd === currentHsdFilter)); render(); }
        function applyRoomFilterUI() { roomFilterChips.forEach(btn => btn.classList.toggle('active', btn.dataset.room === currentRoomFilter)); render(); }

        if (onlyInStockEl) {
          const saved = localStorage.getItem(LS_ONLY_IN);
          if (saved === '1') onlyInStockEl.checked = true;
          onlyInStockEl.addEventListener('change', () => {
            try { localStorage.setItem(LS_ONLY_IN, onlyInStockEl.checked ? '1' : '0'); } catch { }
            render();
          });
        }

        if (hsdFilterChips.length) {
          hsdFilterChips.forEach(btn => btn.addEventListener('click', () => {
            currentHsdFilter = btn.dataset.hsd || 'all';
            try { localStorage.setItem('rfid.hsdFilter', currentHsdFilter); } catch { }
            applyHsdFilterUI();
          }));
          if (!['all', 'safe', 'watch', 'danger'].includes(currentHsdFilter)) currentHsdFilter = 'all';
        }

        if (roomFilterChips.length) {
          if (!['all', 'room1', 'room2', 'room3'].includes(currentRoomFilter)) currentRoomFilter = 'all';
          roomFilterChips.forEach(btn => btn.addEventListener('click', () => {
            currentRoomFilter = btn.dataset.room || 'all';
            try { localStorage.setItem(LS_ROOM_FILTER, currentRoomFilter); } catch { }
            applyRoomFilterUI();
          }));
        }

        loadRows();
        setView(currentView);
        applyHsdFilterUI();
        applyRoomFilterUI();

        return { handleRFIDMessage };
      })();

      // ===== ROOM MODULE =====
      const roomMod = (function () {
        const tbody = document.getElementById('roomTbody');
        const histMaxEl = document.getElementById('histMax');

        const doorBadge = document.getElementById('doorBadge');
        const doorText = document.getElementById('doorText');

        const alarmBadge = document.getElementById('alarmBadge');
        const alarmText = document.getElementById('alarmText');
        const alarmDot = document.getElementById('alarmDot');
        const alarmLED = document.getElementById('alarmLED');

        // ‚úÖ Toggle c·∫£nh b√°o (l∆∞u theo ph√≤ng) + ‚úÖ NEW: ƒë·ªìng b·ªô theo tr·∫°ng th√°i ESP32 (alarmEnable)
        const alarmEnableWebEl = document.getElementById('alarmEnableWeb');
        const LS_ALARM_WEB_PREFIX = 'room.alarmWeb.enable.v1.'; // key theo room: room1/2/3
        const alarmWebEnable = { room1: true, room2: true, room3: true };

        function loadAlarmWebEnable(room) {
          const v = localStorage.getItem(LS_ALARM_WEB_PREFIX + room);
          alarmWebEnable[room] = (v === null) ? true : (v === '1');
        }
        function saveAlarmWebEnable(room) {
          localStorage.setItem(LS_ALARM_WEB_PREFIX + room, alarmWebEnable[room] ? '1' : '0');
        }
        ['room1', 'room2', 'room3'].forEach(loadAlarmWebEnable);

        function isAlarmWebEnabled(room) { return !!alarmWebEnable[room]; }

        function applyAlarmWebUI(room) {
          if (!alarmEnableWebEl) return;
          alarmEnableWebEl.checked = isAlarmWebEnabled(room);

          // n·∫øu t·∫Øt -> ·∫©n ngay tr√™n UI ƒë·ªÉ kh·ªèi ‚Äú·ªìn‚Äù
          if (!isAlarmWebEnabled(room) && room === currentRoom) {
            alarmBadge.classList.add('hidden');
            alarmLED.classList.add('hidden');
            alarmLED.classList.remove('red', 'pulse');
            alarmText.textContent = 'ALARM: ‚Äî';
          }
        }

        const roomLogTbody = document.getElementById('roomLogTbody');

        const rangeLowInput = document.getElementById('rangeLowInput');
        const rangeHighInput = document.getElementById('rangeHighInput');
        const bandSaveBtn = document.getElementById('bandSaveBtn');
        const bandDefaultBtn = document.getElementById('bandDefaultBtn');
        const bandExplain = document.getElementById('bandExplain');

        // AUTO DOM
        const autoSetpoint = document.getElementById('autoSetpoint');
        const autoBoostBand = document.getElementById('autoBoostBand');
        const autoHys = document.getElementById('autoHys');
        const autoMinDuty = document.getElementById('autoMinDuty');
        const autoMaxDuty = document.getElementById('autoMaxDuty');
        const autoApplyBtn = document.getElementById('autoApplyBtn');
        const autoExplain = document.getElementById('autoExplain');

        // ===== FIX: kh√¥ng ghi ƒë√® input AUTO khi user ƒëang g√µ =====
        const autoEdit = { sp: false, boost: false, hys: false, min: false, max: false };
        const autoDirty = { sp: false, boost: false, hys: false, min: false, max: false };

        function bindAutoGuard(el, key) {
          if (!el) return;
          el.addEventListener('focus', () => autoEdit[key] = true);
          el.addEventListener('blur', () => autoEdit[key] = false);
          el.addEventListener('input', () => autoDirty[key] = true);
        }
        bindAutoGuard(autoSetpoint, 'sp');
        bindAutoGuard(autoBoostBand, 'boost');
        bindAutoGuard(autoHys, 'hys');
        bindAutoGuard(autoMinDuty, 'min');
        bindAutoGuard(autoMaxDuty, 'max');

        function safeSetAutoInput(key, el, valueStr) {
          if (!el) return;
          if (autoEdit[key]) return;   // ƒëang g√µ -> kh√¥ng overwrite
          if (autoDirty[key]) return;  // ƒë√£ s·ª≠a nh∆∞ng ch∆∞a Apply -> kh√¥ng overwrite
          el.value = valueStr;
        }


        const LS_HIST_PREFIX = 'roomTH.hist.v1.';
        const LS_HIST_LIMIT = 'roomTH.hist.limit';

        const hist = {
          room1: { labels: [], t: [], h: [] },
          room2: { labels: [], t: [], h: [] },
          room3: { labels: [], t: [], h: [] },
        };

        const ROOM_LOG_MAX = 50;
        const roomLogs = { room1: [], room2: [], room3: [] };

        const ctx = document.getElementById('thChart').getContext('2d');
        const chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              { label: 'Nhi·ªát ƒë·ªô (¬∞C)', data: [], tension: .25, pointRadius: 0, borderWidth: 2, borderColor: 'rgba(239,68,68,0.95)', backgroundColor: 'rgba(239,68,68,0.12)' },
              { label: 'ƒê·ªô ·∫©m (%RH)', data: [], tension: .25, pointRadius: 0, borderWidth: 2, borderColor: 'rgba(37,99,235,0.95)', backgroundColor: 'rgba(37,99,235,0.10)' },
              { label: 'LOW', data: [], tension: 0, pointRadius: 0, borderDash: [6, 4], borderWidth: 1.3, borderColor: 'rgba(16,185,129,0.85)' },
              { label: 'HIGH', data: [], tension: 0, pointRadius: 0, borderDash: [6, 4], borderWidth: 1.3, borderColor: 'rgba(16,185,129,0.85)' },
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'nearest', intersect: false },
            plugins: {
              legend: { labels: { color: getComputedStyle(document.documentElement).getPropertyValue('--text') } }
            },
            scales: {
              x: { ticks: { autoSkip: true, maxRotation: 0, color: getComputedStyle(document.documentElement).getPropertyValue('--muted') }, grid: { color: 'rgba(148,163,184,.15)' } },
              y: { ticks: { color: getComputedStyle(document.documentElement).getPropertyValue('--muted') }, grid: { color: 'rgba(148,163,184,.12)' } }
            }
          }
        });

        const thOverlay = document.getElementById('thModalOverlay');
        const btnOpenTHLog = document.getElementById('btnOpenTHLog');
        const btnCloseTHModal = document.getElementById('btnCloseTHModal');
        const thLogTbody = document.getElementById('thLogTbody');
        const thLogCount = document.getElementById('thLogCount');
        const thLogEnable = document.getElementById('thLogEnable');
        const thLogLimit = document.getElementById('thLogLimit');
        const thLogRoomFilter = document.getElementById('thLogRoomFilter');
        const thLogSearch = document.getElementById('thLogSearch');
        const btnTHExportCSV = document.getElementById('btnTHExportCSV');
        const btnTHClear = document.getElementById('btnTHClear');

        const LS_TH_TABLE = 'roomTH.table.v1';
        const LS_TH_ENABLE = 'roomTH.table.enable';
        const LS_TH_LIMIT = 'roomTH.table.limit';

        let thTable = [];
        function loadTHTable() {
          try {
            thTable = JSON.parse(localStorage.getItem(LS_TH_TABLE) || '[]');
            if (!Array.isArray(thTable)) thTable = [];
          } catch { thTable = []; }

          const en = localStorage.getItem(LS_TH_ENABLE);
          thLogEnable.checked = (en !== '0');

          const lim = Number(localStorage.getItem(LS_TH_LIMIT));
          thLogLimit.value = String((Number.isFinite(lim) && lim >= 100) ? lim : 2000);
        }
        function saveTHTable() { try { localStorage.setItem(LS_TH_TABLE, JSON.stringify(thTable)); } catch { } }

        function openTHModal() {
          thOverlay.classList.add('active');
          thOverlay.setAttribute('aria-hidden', 'false');
          renderTHTable();
        }
        function closeTHModal() {
          thOverlay.classList.remove('active');
          thOverlay.setAttribute('aria-hidden', 'true');
        }

        btnOpenTHLog.addEventListener('click', openTHModal);
        btnCloseTHModal.addEventListener('click', closeTHModal);
        thOverlay.addEventListener('click', (e) => { if (e.target === thOverlay) closeTHModal(); });
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeTHModal(); });

        thLogEnable.addEventListener('change', () => {
          localStorage.setItem(LS_TH_ENABLE, thLogEnable.checked ? '1' : '0');
          setHdr(thLogEnable.checked ? 'ƒê√£ b·∫≠t ghi log T/H' : 'ƒê√£ t·∫Øt ghi log T/H', 'ok');
        });

        thLogLimit.addEventListener('change', () => {
          let lim = Number(thLogLimit.value);
          if (!Number.isFinite(lim) || lim < 100) lim = 100;
          if (lim > 10000) lim = 10000;
          thLogLimit.value = String(lim);
          localStorage.setItem(LS_TH_LIMIT, String(lim));
          if (thTable.length > lim) {
            thTable = thTable.slice(0, lim);
            saveTHTable();
            renderTHTable();
          }
        });

        const renderTHTable = debounce(() => {
          const roomF = thLogRoomFilter.value || 'all';
          const q = (thLogSearch.value || '').trim().toLowerCase();

          let view = thTable;
          if (roomF !== 'all') view = view.filter(x => x.room === roomF);
          if (q) view = view.filter(x => (x.iso || '').toLowerCase().includes(q) || (x.note || '').toLowerCase().includes(q));

          thLogCount.textContent = String(view.length);
          thLogTbody.innerHTML = '';

          view.forEach(r => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td class="mono">${r.iso || ''}</td>
              <td class="mono">${r.room || ''}</td>
              <td class="mono"><b>${Number(r.t).toFixed(1)}</b></td>
              <td class="mono"><b>${Number(r.h).toFixed(1)}</b></td>
              <td>${r.note || ''}</td>
            `;
            thLogTbody.appendChild(tr);
          });
        }, 80);

        thLogRoomFilter.addEventListener('change', renderTHTable);
        thLogSearch.addEventListener('input', renderTHTable);

        btnTHClear.addEventListener('click', () => {
          thTable = [];
          saveTHTable();
          renderTHTable();
          setHdr('ƒê√£ xo√° to√†n b·ªô log T/H', 'warn');
        });

        btnTHExportCSV.addEventListener('click', () => {
          const hdr = ['timestamp_iso', 'room', 'temp_c', 'humi_rh', 'note'];
          const csv = [hdr.join(',')].concat(thTable.map(r => {
            const row = {
              timestamp_iso: r.iso || '',
              room: r.room || '',
              temp_c: Number(r.t).toFixed(1),
              humi_rh: Number(r.h).toFixed(1),
              note: r.note || ''
            };
            return hdr.map(k => '"' + String(row[k]).replace(/"/g, '""') + '"').join(',');
          })).join('\n');

          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'room-th-log.csv';
          a.click();
          URL.revokeObjectURL(a.href);
        });

        function pushTHLog(room, t, h, note = '') {
          if (!thLogEnable.checked) return;

          const lim = Number(localStorage.getItem(LS_TH_LIMIT)) || Number(thLogLimit.value) || 2000;
          const iso = new Date().toISOString().replace('T', ' ').slice(0, 19);

          thTable.unshift({ ts: Date.now(), iso, room, t: Number(t), h: Number(h), note });
          if (thTable.length > lim) thTable.length = lim;
          saveTHTable();

          if (thOverlay.classList.contains('active')) renderTHTable();
        }

        function renderRoomLog(room) {
          if (!roomLogTbody) return;
          roomLogTbody.innerHTML = '';
          const arr = roomLogs[room] || [];
          arr.forEach(e => {
            const timeStr = new Date(e.ts).toLocaleString('vi-VN', { hour12: false });
            const tr = document.createElement('tr');
            tr.innerHTML = `<td class="mono">${timeStr}</td><td>${e.type}</td><td>${e.message}</td>`;
            roomLogTbody.appendChild(tr);
          });
        }

        function pushRoomLog(room, type, message) {
          const arr = roomLogs[room];
          if (!arr) return;
          arr.unshift({ ts: Date.now(), type, message });
          if (arr.length > ROOM_LOG_MAX) arr.length = ROOM_LOG_MAX;
          if (room === currentRoom) renderRoomLog(room);
        }

        function limitForHist() {
          const v = Number(localStorage.getItem(LS_HIST_LIMIT));
          const n = Number.isFinite(v) && v >= 50 && v <= 2000 ? v : Number(histMaxEl.value) || 200;
          return Math.max(50, Math.min(2000, n));
        }

        function persistHistory(room) {
          try {
            localStorage.setItem(LS_HIST_PREFIX + room, JSON.stringify(hist[room]));
            localStorage.setItem(LS_HIST_LIMIT, String(limitForHist()));
          } catch (e) { }
        }

        function loadHistory(room) {
          try {
            const p = JSON.parse(localStorage.getItem(LS_HIST_PREFIX + room) || 'null');
            if (p && Array.isArray(p.labels)) {
              hist[room].labels = p.labels || [];
              hist[room].t = p.t || [];
              hist[room].h = p.h || [];
            }
          } catch (e) { }
        }
        ['room1', 'room2', 'room3'].forEach(loadHistory);
        histMaxEl.value = limitForHist();

        const pelCache = { room1: null, room2: null, room3: null };
        const stateCache = {
          room1: { door: null, alarmTemp: null, alarmDir: 0, alarmEnable: null },
          room2: { door: null, alarmTemp: null, alarmDir: 0, alarmEnable: null },
          room3: { door: null, alarmTemp: null, alarmDir: 0, alarmEnable: null },
        };

        // ‚úÖ NEW: khi user b·∫•m toggle -> v·ª´a t·∫Øt UI Web, v·ª´a g·ª≠i l·ªánh xu·ªëng ESP32 (alarmEnable)
        if (alarmEnableWebEl) {
          alarmEnableWebEl.addEventListener('change', () => {
            alarmWebEnable[currentRoom] = !!alarmEnableWebEl.checked;
            saveAlarmWebEnable(currentRoom);

            // ‚úÖ NEW: publish xu·ªëng ESP32 ƒë·ªÉ t·∫Øt/b·∫≠t c·∫£nh b√°o ph·∫ßn c·ª©ng
            // ESP32 s·∫Ω nh·∫≠n ·ªü topic coldroom/<room>/peltier_cmd v·ªõi key: alarmEnable
            sendPelCmd({ alarmEnable: alarmEnableWebEl.checked ? 1 : 0 });

            if (!alarmEnableWebEl.checked) {
              alarmBadge.classList.add('hidden');
              alarmLED.classList.add('hidden');
              alarmLED.classList.remove('red', 'pulse');
              alarmText.textContent = 'ALARM: ‚Äî';
              setHdr('ƒê√£ T·∫ÆT c·∫£nh b√°o (Web + ph·∫ßn c·ª©ng) cho ' + currentRoom, 'warn');
            } else {
              setHdr('ƒê√£ B·∫¨T c·∫£nh b√°o (Web + ph·∫ßn c·ª©ng) cho ' + currentRoom, 'ok');
              const st = stateCache[currentRoom];
              if (st && st.alarmTemp === 1) updateAlarmBadge(currentRoom, 1, st.alarmDir || 0);
            }
          });
        }

        function lowHighSeriesFor(room) {
          const c = pelCache[room];
          const len = hist[room].labels.length;
          const fill = (v) => Array.from({ length: len }, () => (Number.isFinite(v) ? v : null));
          return { lo: fill(c?.lowC), hi: fill(c?.highC) };
        }

        function refreshBandsLinesFor(room) {
          const s = lowHighSeriesFor(room);
          chart.data.datasets[2].data = s.lo;
          chart.data.datasets[3].data = s.hi;
        }

        function applyChartRoom(room) {
          chart.data.labels = hist[room].labels;
          chart.data.datasets[0].data = hist[room].t;
          chart.data.datasets[1].data = hist[room].h;
          refreshBandsLinesFor(room);
          chart.update('none');
        }

        function appendTelemetry(room, t, h) {
          const L = limitForHist();
          const d = hist[room];
          d.labels.push(new Date().toLocaleTimeString('vi-VN', { hour12: false }));
          d.t.push(Number(t));
          d.h.push(Number(h));
          while (d.labels.length > L) { d.labels.shift(); d.t.shift(); d.h.shift(); }
          if (room === currentRoom) { refreshBandsLinesFor(room); chart.update('none'); }
          persistHistory(room);
        }

        histMaxEl.addEventListener('change', () => {
          const L = limitForHist();
          localStorage.setItem(LS_HIST_LIMIT, String(L));
          const d = hist[currentRoom];
          while (d.labels.length > L) { d.labels.shift(); d.t.shift(); d.h.shift(); }
          applyChartRoom(currentRoom);
          persistHistory(currentRoom);
        });

        const rangeBtns = Array.from(document.querySelectorAll('.rangebtn'));
        let currentRangeMode = localStorage.getItem('room.histRange') || 'auto';

        function applyRangeMode(mode) {
          currentRangeMode = mode || 'auto';
          try { localStorage.setItem('room.histRange', currentRangeMode); } catch { }
          rangeBtns.forEach(b => b.classList.toggle('active', b.dataset.range === currentRangeMode));
          if (currentRangeMode === 'auto') return;
          let val = 200;
          if (currentRangeMode === '30m') val = 300;
          else if (currentRangeMode === '2h') val = 800;
          else if (currentRangeMode === '24h') val = 2000;
          histMaxEl.value = String(val);
          histMaxEl.dispatchEvent(new Event('change'));
        }

        if (rangeBtns.length) {
          rangeBtns.forEach(btn => btn.addEventListener('click', () => applyRangeMode(btn.dataset.range)));
          if (!['auto', '30m', '2h', '24h'].includes(currentRangeMode)) currentRangeMode = 'auto';
          applyRangeMode(currentRangeMode);
        }

        document.getElementById('histClear').addEventListener('click', () => {
          const d = hist[currentRoom];
          d.labels = []; d.t = []; d.h = [];
          applyChartRoom(currentRoom);
          try { localStorage.removeItem(LS_HIST_PREFIX + currentRoom); } catch (e) { }
          setHdr('ƒê√£ xo√° l·ªãch s·ª≠ bi·ªÉu ƒë·ªì', 'warn');
        });

        function updateDoorBadge(room, val01) {
          const open = Number(val01) === 1;
          const prev = stateCache[room].door;
          if (room === currentRoom) {
            doorBadge.classList.remove('open', 'closed');
            doorBadge.classList.add(open ? 'open' : 'closed');
            doorText.textContent = 'Door: ' + (open ? 'OPEN' : 'CLOSED');
          }
          stateCache[room].door = open ? 1 : 0;
          if (prev !== null && prev !== stateCache[room].door) pushRoomLog(room, 'Door', open ? 'C·ª≠a m·ªü' : 'C·ª≠a ƒë√≥ng');
        }

        function updateAlarmBadge(room, val01, dir) {
          // n·∫øu Web t·∫Øt c·∫£nh b√°o cho ph√≤ng n√†y -> kh√¥ng hi·ªÉn th·ªã / kh√¥ng log / kh√¥ng ‚Äú·ªìn‚Äù
          if (!isAlarmWebEnabled(room)) {
            stateCache[room].alarmTemp = (Number(val01) === 1) ? 1 : 0;
            stateCache[room].alarmDir = Number(dir) || 0;

            if (room === currentRoom) {
              alarmBadge.classList.add('hidden');
              alarmLED.classList.add('hidden');
              alarmLED.classList.remove('red', 'pulse');
              alarmText.textContent = 'ALARM: ‚Äî';
            }
            return;
          }

          const on = Number(val01) === 1;
          const prev = stateCache[room].alarmTemp;
          stateCache[room].alarmDir = Number(dir) || 0;

          if (room === currentRoom) {
            alarmBadge.classList.toggle('hidden', !on);

            const dirTxt = (stateCache[room].alarmDir < 0) ? 'QU√Å TH·∫§P' : (stateCache[room].alarmDir > 0) ? 'QU√Å CAO' : 'V∆Ø·ª¢T NG∆Ø·ª†NG';
            alarmText.textContent = on ? ('ALARM: ' + dirTxt) : 'ALARM: ‚Äî';

            alarmDot.className = 'dot ' + (on ? 'err' : '');
            alarmLED.classList.toggle('hidden', !on);

            if (on) {
              alarmLED.classList.add('red', 'pulse');
              if (prev !== 1) setHdr('C·∫£nh b√°o: Nhi·ªát ƒë·ªô ' + dirTxt + '!', 'err');
            } else {
              alarmLED.classList.remove('red', 'pulse');
            }
          }

          stateCache[room].alarmTemp = on ? 1 : 0;
          if (prev !== null && prev !== stateCache[room].alarmTemp) {
            pushRoomLog(room, 'Nhi·ªát ƒë·ªô', on ? 'B·∫¨T c·∫£nh b√°o nhi·ªát ƒë·ªô' : 'T·∫ÆT c·∫£nh b√°o (v·ªÅ d·∫£i an to√†n)');
          }
        }

        // ‚úÖ NEW: ƒë·ªìng b·ªô toggle theo alarmEnable t·ª´ ESP32
        function syncAlarmEnableFromESP(room, val01) {
          const en = Number(val01) === 1;
          stateCache[room].alarmEnable = en ? 1 : 0;

          // ƒë·ªìng b·ªô ‚Äúch√≠nh s√°ch hi·ªÉn th·ªã‚Äù c·ªßa web lu√¥n theo ph·∫ßn c·ª©ng (ƒë·ªÉ kh·ªèi l·ªách)
          alarmWebEnable[room] = en;
          try { localStorage.setItem(LS_ALARM_WEB_PREFIX + room, en ? '1' : '0'); } catch { }

          if (room === currentRoom && alarmEnableWebEl) {
            alarmEnableWebEl.checked = en;
            // n·∫øu ph·∫ßn c·ª©ng t·∫Øt -> web c≈©ng ·∫©n lu√¥n
            applyAlarmWebUI(room);
          }
        }

        function handleStateFrom(room, msg) {
          try {
            const o = JSON.parse(msg);

            // ‚úÖ NEW: nh·∫≠n alarmEnable t·ª´ ESP32
            if (o.alarmEnable !== undefined) {
              syncAlarmEnableFromESP(room, o.alarmEnable);
            }

            if (o.door !== undefined) {
              const dv = o.door === true ? 1 : o.door === false ? 0 : Number(o.door);
              if (dv === 0 || dv === 1) updateDoorBadge(room, dv);
            }
            if (o.alarmTemp !== undefined) {
              const av = o.alarmTemp === true ? 1 : o.alarmTemp === false ? 0 : Number(o.alarmTemp);
              const dir = (o.alarmDir !== undefined) ? Number(o.alarmDir) : 0;
              if (av === 0 || av === 1) updateAlarmBadge(room, av, dir);
            }
          } catch (e) { console.warn('STATE JSON error', e); }
        }

        function handleTelemetryFrom(room, msg) {
          let t = null, h = null, av = null, dir = 0;
          try {
            const o = JSON.parse(msg);

            // ‚úÖ NEW: nh·∫≠n alarmEnable t·ª´ ESP32 (tele)
            if (o.alarmEnable !== undefined) {
              syncAlarmEnableFromESP(room, o.alarmEnable);
            }

            t = o.temp ?? o.temperature ?? o.T ?? null;
            h = o.humi ?? o.humidity ?? o.H ?? null;
            if (o.alarmTemp !== undefined) av = o.alarmTemp === true ? 1 : o.alarmTemp === false ? 0 : Number(o.alarmTemp);
            if (o.alarmDir !== undefined) dir = Number(o.alarmDir) || 0;
          } catch (e) {
            const parts = String(msg).split(/[;,\s]+/).filter(Boolean);
            if (parts.length >= 2) { t = parseFloat(parts[0]); h = parseFloat(parts[1]); }
          }

          if (Number.isFinite(t) && Number.isFinite(h)) {
            if (room === currentRoom) {
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>${Number(t).toFixed(1)}</td><td>${Number(h).toFixed(1)}</td>`;
              tbody.replaceChildren(tr);
              const tEl = document.getElementById('tempBig');
              const hEl = document.getElementById('humiBig');
              if (tEl) tEl.textContent = Number(t).toFixed(1);
              if (hEl) hEl.textContent = Number(h).toFixed(1);
            }

            appendTelemetry(room, t, h);

            const note = stateCache[room]?.alarmTemp ? 'ALARM ON' : '';
            pushTHLog(room, t, h, note);
          }
          if (av === 0 || av === 1) updateAlarmBadge(room, av, dir);
        }

        const LS_PEL_PREFIX = 'pel.ctrl.v6.';
        const pelKey = room => LS_PEL_PREFIX + room;

        function loadPel(room) {
          const defR = defaultRange(room);
          const spDef = defR.low;
          const def = {
            mode: 'manual', enable: 1, duty: 0, minDuty: 0, maxDuty: 255,
            setpointC: spDef,
            boostBandC: 2.0,
            autoHysC: 0.3,
            autoMinDuty: 80,
            autoMaxDuty: 255,
            lowC: defR.low, highC: defR.high,
            ...bandsFromLowHigh(defR.low, defR.high),
          };

          try {
            const s = JSON.parse(localStorage.getItem(pelKey(room)) || 'null');
            if (s && typeof s === 'object') {
              const toNum = (x, fb) => { const v = parseFloat(x); return Number.isFinite(v) ? v : fb; };
              const lowC = toNum(s.lowC, def.lowC);
              const highC = toNum(s.highC, def.highC);
              const b = bandsFromLowHigh(lowC, highC) || bandsFromLowHigh(def.lowC, def.highC);

              const mode = String(s.mode || 'manual').toLowerCase();
              return {
                mode: (mode === 'off') ? 'off' : (mode === 'auto' ? 'auto' : 'manual'),
                enable: s.enable ? 1 : 0,
                duty: clamp(s.duty ?? 0, 0, 255),
                minDuty: clamp(s.minDuty ?? 0, 0, 255),
                maxDuty: clamp(s.maxDuty ?? 255, 0, 255),

                setpointC: toNum(s.setpointC, def.setpointC),
                boostBandC: toNum(s.boostBandC, def.boostBandC),
                autoHysC: toNum(s.autoHysC, def.autoHysC),
                autoMinDuty: clamp(s.autoMinDuty ?? def.autoMinDuty, 0, 255),
                autoMaxDuty: clamp(s.autoMaxDuty ?? def.autoMaxDuty, 0, 255),

                lowC: b.low,
                highC: b.high,
                alarmLowC: b.alarmLowC,
                alarmHighC: b.alarmHighC,
                clearLowC: b.clearLowC,
                clearHighC: b.clearHighC,
              };
            }
          } catch (e) { }
          return def;
        }

        function savePel(room) {
          try {
            const c = pelCache[room];
            const pack = {
              mode: c.mode || 'manual',
              enable: c.enable ? 1 : 0,
              duty: clamp(c.duty ?? 0, 0, 255),
              minDuty: clamp(c.minDuty ?? 0, 0, 255),
              maxDuty: clamp(c.maxDuty ?? 255, 0, 255),

              setpointC: Number(c.setpointC),
              boostBandC: Number(c.boostBandC),
              autoHysC: Number(c.autoHysC),
              autoMinDuty: clamp(c.autoMinDuty ?? 0, 0, 255),
              autoMaxDuty: clamp(c.autoMaxDuty ?? 255, 0, 255),

              lowC: c.lowC,
              highC: c.highC,

              alarmLowC: c.alarmLowC,
              alarmHighC: c.alarmHighC,
              clearLowC: c.clearLowC,
              clearHighC: c.clearHighC,
            };
            localStorage.setItem(pelKey(room), JSON.stringify(pack));
          } catch (e) { }
        }

        pelCache.room1 = loadPel('room1');
        pelCache.room2 = loadPel('room2');
        pelCache.room3 = loadPel('room3');

        const pelEnable = document.getElementById('peltierEnable');
        const pelSlider = document.getElementById('peltierSlider');
        const pelDutyLbl = document.getElementById('pelDutyLbl');
        const pelPctLbl = document.getElementById('pelPctLbl');
        const pelModeLbl = document.getElementById('pelModeLbl');
        const modeAutoBtn = document.getElementById('modeAuto');
        const modeManualBtn = document.getElementById('modeManual');
        const modeOffBtn = document.getElementById('modeOff');

        let isDraggingDuty = false;
        let isEditingRange = false;

        function setRangeInputsFromCache(room) {
          const c = pelCache[room];
          if (!c) return;
          if (!isEditingRange) {
            rangeLowInput.value = Number(c.lowC).toFixed(1);
            rangeHighInput.value = Number(c.highC).toFixed(1);
          }
          bandExplain.textContent =
            `ALARM: ${Number(c.alarmLowC).toFixed(1)}‚Äì${Number(c.alarmHighC).toFixed(1)}¬∞C | ` +
            `T·∫ÆT khi v·ªÅ: ${Number(c.clearLowC).toFixed(1)}‚Äì${Number(c.clearHighC).toFixed(1)}¬∞C`;
        }

        function setAutoInputsFromCache(room) {
          const c = pelCache[room];
          if (!c) return;
          safeSetAutoInput('sp', autoSetpoint, Number(c.setpointC).toFixed(1));
          safeSetAutoInput('boost', autoBoostBand, Number(c.boostBandC).toFixed(1));
          safeSetAutoInput('hys', autoHys, Number(c.autoHysC).toFixed(1));
          safeSetAutoInput('min', autoMinDuty, String(clamp(c.autoMinDuty ?? 0, 0, 255)));
          safeSetAutoInput('max', autoMaxDuty, String(clamp(c.autoMaxDuty ?? 255, 0, 255)));
          autoExplain.textContent =
            `SP=${Number(c.setpointC).toFixed(1)}¬∞C, boost=${Number(c.boostBandC).toFixed(1)}¬∞C, hys=${Number(c.autoHysC).toFixed(1)}¬∞C`;
        }

        function applyPeltierUI(room) {
          const c = pelCache[room];

          pelModeLbl.textContent = String(c.mode || '‚Äî').toUpperCase();
          [modeAutoBtn, modeManualBtn, modeOffBtn].forEach(b => b.classList.remove('active'));
          if (c.mode === 'auto') modeAutoBtn.classList.add('active');
          else if (c.mode === 'manual') modeManualBtn.classList.add('active');
          else if (c.mode === 'off') modeOffBtn.classList.add('active');

          pelEnable.checked = !!c.enable;

          pelSlider.min = String(Number.isFinite(c.minDuty) ? c.minDuty : 0);
          pelSlider.max = String(Number.isFinite(c.maxDuty) ? c.maxDuty : 255);
          if (!isDraggingDuty && Number.isFinite(c.duty)) pelSlider.value = String(c.duty);

          pelDutyLbl.textContent = Number.isFinite(c.duty) ? c.duty : (pelSlider.value | 0);
          pelPctLbl.textContent = Math.round(100 * (pelSlider.value | 0) / 255);

          pelSlider.disabled = (!pelEnable.checked) || (c.mode !== 'manual');

          setAutoInputsFromCache(room);
          setRangeInputsFromCache(room);

          refreshBandsLinesFor(room);
          if (room === currentRoom) chart.update('none');
        }

        function handlePeltierStateFrom(room, json) {
          try {
            const o = JSON.parse(json);
            const c = pelCache[room];

            // ‚úÖ NEW: nh·∫≠n alarmEnable n·∫øu firmware g·ª≠i trong peltier_state
            if (o.alarmEnable !== undefined) {
              syncAlarmEnableFromESP(room, o.alarmEnable);
            }

            const m = String(o.mode || c.mode || 'manual').toLowerCase();
            c.mode = (m === 'off') ? 'off' : (m === 'auto' ? 'auto' : 'manual');

            if (o.enable !== undefined) c.enable = o.enable ? 1 : 0;
            if (typeof o.duty === 'number') c.duty = clamp(o.duty, 0, 255);
            if (typeof o.minDuty === 'number') c.minDuty = clamp(o.minDuty, 0, 255);
            if (typeof o.maxDuty === 'number') c.maxDuty = clamp(o.maxDuty, 0, 255);

            if (typeof o.setpointC === 'number') c.setpointC = o.setpointC;
            if (typeof o.boostBandC === 'number') c.boostBandC = o.boostBandC;
            if (typeof o.autoHysC === 'number') c.autoHysC = o.autoHysC;
            if (typeof o.autoMinDuty === 'number') c.autoMinDuty = clamp(o.autoMinDuty, 0, 255);
            if (typeof o.autoMaxDuty === 'number') c.autoMaxDuty = clamp(o.autoMaxDuty, 0, 255);

            if (typeof o.alarmLowC === 'number') c.alarmLowC = o.alarmLowC;
            if (typeof o.alarmHighC === 'number') c.alarmHighC = o.alarmHighC;
            if (typeof o.clearLowC === 'number') c.clearLowC = o.clearLowC;
            if (typeof o.clearHighC === 'number') c.clearHighC = o.clearHighC;

            const derived = deriveLowHighFromBands(c);
            if (derived) {
              c.lowC = derived.low;
              c.highC = derived.high;
            } else {
              const b = bandsFromLowHigh(c.lowC, c.highC);
              if (b) Object.assign(c, b);
            }

            savePel(room);
            if (room === currentRoom) applyPeltierUI(room);
          } catch (e) { console.warn('PELTIER_STATE JSON error', e); }
        }

        function handlePeltierTeleFrom(room, json) {
          try {
            const o = JSON.parse(json);
            const c = pelCache[room];

            // ‚úÖ NEW: nh·∫≠n alarmEnable n·∫øu firmware g·ª≠i trong peltier_tele
            if (o.alarmEnable !== undefined) {
              syncAlarmEnableFromESP(room, o.alarmEnable);
            }

            if (typeof o.duty === 'number') c.duty = clamp(o.duty, 0, 255);
            if (typeof o.mode === 'string') {
              const m = o.mode.toLowerCase();
              c.mode = (m === 'off') ? 'off' : (m === 'auto' ? 'auto' : 'manual');
            }
            savePel(room);
            if (room === currentRoom) applyPeltierUI(room);

            if (o.alarmTemp !== undefined) {
              const av = o.alarmTemp === true ? 1 : o.alarmTemp === false ? 0 : Number(o.alarmTemp);
              const dir = (o.alarmDir !== undefined) ? Number(o.alarmDir) : 0;
              if (av === 0 || av === 1) updateAlarmBadge(room, av, dir);
            }
          } catch (e) { console.warn('PELTIER_TELE JSON error', e); }
        }

        pelEnable.addEventListener('change', () => {
          const v = pelEnable.checked ? 1 : 0;
          pelCache[currentRoom].enable = v;
          savePel(currentRoom);
          sendPelCmd({ enable: !!v });
        });

        modeManualBtn.addEventListener('click', () => {
          pelCache[currentRoom].mode = 'manual';
          savePel(currentRoom);
          applyPeltierUI(currentRoom);
          sendPelCmd({ mode: 'manual', duty: (pelSlider.value | 0), enable: !!pelEnable.checked });
        });

        modeOffBtn.addEventListener('click', () => {
          pelCache[currentRoom].mode = 'off';
          savePel(currentRoom);
          applyPeltierUI(currentRoom);
          sendPelCmd({ mode: 'off', enable: 0 });
        });

        modeAutoBtn.addEventListener('click', () => {
          pelCache[currentRoom].mode = 'auto';
          savePel(currentRoom);
          applyPeltierUI(currentRoom);
          const c = pelCache[currentRoom];
          sendPelCmd({
            mode: 'auto',
            enable: !!pelEnable.checked,
            setpointC: Number(c.setpointC),
            boostBandC: Number(c.boostBandC),
            autoHysC: Number(c.autoHysC),
            autoMinDuty: clamp(c.autoMinDuty, 0, 255),
            autoMaxDuty: clamp(c.autoMaxDuty, 0, 255),
          });
        });

        const sendDutyDebounced = debounce(() => {
          const d = pelSlider.value | 0;
          pelCache[currentRoom].duty = d;
          savePel(currentRoom);
          sendPelCmd({ mode: 'manual', duty: d, enable: !!pelEnable.checked });
          isDraggingDuty = false;
        }, 140);

        pelSlider.addEventListener('input', () => {
          isDraggingDuty = true;
          pelDutyLbl.textContent = pelSlider.value;
          pelCache[currentRoom].duty = pelSlider.value | 0;
          savePel(currentRoom);
          sendDutyDebounced();
        });

        pelSlider.addEventListener('change', () => {
          isDraggingDuty = false;
          const d = pelSlider.value | 0;
          pelCache[currentRoom].duty = d;
          savePel(currentRoom);
          sendPelCmd({ mode: 'manual', duty: d, enable: !!pelEnable.checked });
        });

        // AUTO Apply
        autoApplyBtn.addEventListener('click', () => {
          autoDirty.sp = autoDirty.boost = autoDirty.hys = autoDirty.min = autoDirty.max = false;
          const c = pelCache[currentRoom];
          c.setpointC = parseFloat(autoSetpoint.value);
          c.boostBandC = parseFloat(autoBoostBand.value);
          c.autoHysC = parseFloat(autoHys.value);
          c.autoMinDuty = clamp(parseInt(autoMinDuty.value || '0', 10), 0, 255);
          c.autoMaxDuty = clamp(parseInt(autoMaxDuty.value || '255', 10), 0, 255);
          if (c.autoMaxDuty < c.autoMinDuty) { const t = c.autoMaxDuty; c.autoMaxDuty = c.autoMinDuty; c.autoMinDuty = t; }
          savePel(currentRoom);
          applyPeltierUI(currentRoom);

          pelCache[currentRoom].mode = 'auto';
          savePel(currentRoom);

          sendPelCmd({
            mode: 'auto',
            enable: !!pelEnable.checked,
            setpointC: Number(c.setpointC),
            boostBandC: Number(c.boostBandC),
            autoHysC: Number(c.autoHysC),
            autoMinDuty: clamp(c.autoMinDuty, 0, 255),
            autoMaxDuty: clamp(c.autoMaxDuty, 0, 255),
          });
          setHdr('ƒê√£ √°p d·ª•ng AUTO', 'ok');
        });

        [rangeLowInput, rangeHighInput].forEach(inp => {
          inp.addEventListener('focus', () => isEditingRange = true);
          inp.addEventListener('blur', () => { setTimeout(() => { isEditingRange = false; }, 120); });
        });

        function readLowHighFromInputs() {
          const low = parseFloat(rangeLowInput.value);
          const high = parseFloat(rangeHighInput.value);
          const b = bandsFromLowHigh(low, high);
          return b;
        }

        bandSaveBtn.addEventListener('click', () => {
          const b = readLowHighFromInputs();
          if (!b) { setHdr('Ng∆∞·ª°ng kh√¥ng h·ª£p l·ªá (c·∫ßn ƒë·ªß 2 s·ªë LOW/HIGH)', 'err'); return; }

          Object.assign(pelCache[currentRoom], b);
          savePel(currentRoom);
          applyPeltierUI(currentRoom);

          sendPelCmd({ alarmLowC: b.alarmLowC, alarmHighC: b.alarmHighC, clearLowC: b.clearLowC, clearHighC: b.clearHighC });
        });

        bandDefaultBtn.addEventListener('click', () => {
          const r = defaultRange(currentRoom);
          const b = bandsFromLowHigh(r.low, r.high);
          Object.assign(pelCache[currentRoom], b);
          savePel(currentRoom);
          applyPeltierUI(currentRoom);

          sendPelCmd({ alarmLowC: b.alarmLowC, alarmHighC: b.alarmHighC, clearLowC: b.clearLowC, clearHighC: b.clearHighC });
          setHdr('ƒê√£ √°p d·ª•ng ng∆∞·ª°ng m·∫∑c ƒë·ªãnh theo ' + currentRoom, 'ok');
        });

        function pushPelFromStorage(room) {
          const s = pelCache[room];

          if (s.mode === 'off') {
            sendPelCmd({ mode: 'off', enable: 0 });
          } else if (s.mode === 'auto') {
            sendPelCmd({
              mode: 'auto',
              enable: !!s.enable,
              setpointC: Number(s.setpointC),
              boostBandC: Number(s.boostBandC),
              autoHysC: Number(s.autoHysC),
              autoMinDuty: clamp(s.autoMinDuty, 0, 255),
              autoMaxDuty: clamp(s.autoMaxDuty, 0, 255),
            });
          } else {
            sendPelCmd({ mode: 'manual', duty: (s.duty | 0), enable: !!s.enable });
          }

          // lu√¥n push band nhi·ªát ƒë·ªô
          sendPelCmd({ alarmLowC: s.alarmLowC, alarmHighC: s.alarmHighC, clearLowC: s.clearLowC, clearHighC: s.clearHighC });
        }

        function applyRoomSwitch(room) {
          renderRoomLog(room);
          applyChartRoom(room);
          applyPeltierUI(room);
          applyAlarmWebUI(room);

          if (client && client.connected) {
            try { client.publish(TOPIC.pub(room), JSON.stringify({ getState: 1 }), { qos: 0, retain: false }); } catch (e) { }
          }
          setTimeout(() => pushPelFromStorage(room), 300);
        }

        loadTHTable();
        applyPeltierUI(currentRoom);
        renderTHTable();
        applyAlarmWebUI(currentRoom);

        return {
          handleStateFrom,
          handleTelemetryFrom,
          handlePeltierStateFrom,
          handlePeltierTeleFrom,
          applyRoomSwitch,
          pushPelFromStorage,
        };
      })();

      // ===== ROOM selector =====
      const roomBtns = Array.from(document.querySelectorAll('.roombtn'));
      const roomBrokerEl = document.getElementById('roomBroker');
      const roomSubEl = document.getElementById('roomSub');
      const roomStateEl = document.getElementById('roomState');
      const roomPubEl = document.getElementById('roomPub');
      const pelCmdTopicEl = document.getElementById('pelCmdTopic');
      const pelStateTopicEl = document.getElementById('pelStateTopic');
      const pelTeleTopicEl = document.getElementById('pelTeleTopic');

      function refreshRoomLabels() {
        roomBrokerEl.textContent = `${HOST}:${PORT}${PATH}`;
        roomSubEl.textContent = TOPIC.teleOf(currentRoom);
        roomStateEl.textContent = TOPIC.stateOf(currentRoom);
        roomPubEl.textContent = TOPIC.pub(currentRoom);
        pelCmdTopicEl.textContent = TOPIC.peltierCmdOf(currentRoom);
        pelStateTopicEl.textContent = `coldroom/${currentRoom}/peltier_state`;
        pelTeleTopicEl.textContent = `coldroom/${currentRoom}/peltier_tele`;
      }

      function setCurrentRoom(room) {
        if (!ROOMS.includes(room)) return;
        currentRoom = room;
        localStorage.setItem('coldroom.currentRoom', currentRoom);
        roomBtns.forEach(b => b.classList.toggle('active', b.dataset.room === room));
        refreshRoomLabels();
        roomMod.applyRoomSwitch(room);
      }

      roomBtns.forEach(b => b.addEventListener('click', () => setCurrentRoom(b.dataset.room)));
      refreshRoomLabels();
      setCurrentRoom(currentRoom);

      // RFID labels
      document.getElementById('rfidBroker').textContent = `${HOST}:${PORT}${PATH}`;
      document.getElementById('rfidTopic').textContent = TOPIC.rfid;

      // ===== MQTT connect =====
      setHdr('ƒêang k·∫øt n·ªëi‚Ä¶', 'warn');
      client = mqtt.connect(WS_URL, {
        clientId: 'webapp-' + Math.random().toString(16).slice(2),
        username: USERNAME,
        password: PASSWORD,
        clean: true,
        reconnectPeriod: 2000,
        connectTimeout: 15000,
        keepalive: 60,
        protocolVersion: 4,
      });

      client.on('connect', () => {
        setHdr('ƒê√£ k·∫øt n·ªëi', 'ok');
        client.subscribe(
          [TOPIC.rfid, TOPIC.tele, TOPIC.state, TOPIC.peltierState, TOPIC.peltierTele],
          { qos: 0 },
          err => {
            if (err) setHdr('Sub l·ªói: ' + err.message, 'err');
            else {
              try { client.publish(TOPIC.pub(currentRoom), JSON.stringify({ getState: 1 }), { qos: 0, retain: false }); } catch (e) { }
              setTimeout(() => roomMod.pushPelFromStorage(currentRoom), 400);
            }
          }
        );
      });

      client.on('reconnect', () => setHdr('ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i‚Ä¶', 'warn'));
      client.on('close', () => setHdr('M·∫•t k·∫øt n·ªëi', 'err'));
      client.on('error', e => setHdr('L·ªói: ' + (e?.message || e), 'err'));

      client.on('message', (topic, payload) => {
        const msg = payload.toString();
        if (topic === TOPIC.rfid) return rfidModule.handleRFIDMessage(msg);
        const room = parseRoomFromTopic(topic);

        if (topic.startsWith('coldroom/') && topic.endsWith('/out1'))
          return roomMod.handleStateFrom(room, msg);

        if (topic.startsWith('coldroom/') && topic.endsWith('/DHT22'))
          return roomMod.handleTelemetryFrom(room, msg);

        if (topic.startsWith('coldroom/') && topic.endsWith('/peltier_state'))
          return roomMod.handlePeltierStateFrom(room, msg);

        if (topic.startsWith('coldroom/') && topic.endsWith('/peltier_tele'))
          return roomMod.handlePeltierTeleFrom(room, msg);
      });

      console.warn('‚ö†Ô∏è L∆∞u √Ω: MQTT USERNAME/PASSWORD ƒëang ·ªü client-side. Khi tri·ªÉn khai th·∫≠t n√™n d√πng proxy ho·∫∑c token t·∫°m th·ªùi.');
    })();
  </script>

</body>

</html>